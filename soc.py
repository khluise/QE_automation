import sys
import os
import re
import subprocess
import shutil
import math
import argparse
from datetime import datetime
import matplotlib.pyplot as plt
import numpy as np
import csv
import glob
import shutil
import matplotlib as mpl
from collections import Counter


class CIF2QESOC:
    def __init__(self):
        self.version = "1.2"
        self.bohr = 0.52917720859
        self.tol = 0.0001  # Tolerance for recognizing identical atoms generated by symmetry
        self.separation = 0.03  # Separation (in A) to generate K Points
        
        # Atomic symbols and masses
        self.atom_symbols = [
            "H", "He", "Li", "Be", "B", "C", "N", "O", "F", "Ne", "Na", "Mg", "Al", "Si", "P", "S", "Cl", "Ar",
            "K", "Ca", "Sc", "Ti", "V", "Cr", "Mn", "Fe", "Co", "Ni", "Cu", "Zn", "Ga", "Ge", "As", "Se", "Br", "Kr",
            "Rb", "Sr", "Y", "Zr", "Nb", "Mo", "Tc", "Ru", "Rh", "Pd", "Ag", "Cd", "In", "Sn", "Sb", "Te", "I", "Xe",
            "Cs", "Ba", "La", "Ce", "Pr", "Nd", "Pm", "Sm", "Eu", "Gd", "Tb", "Dy", "Ho", "Er", "Tm", "Yb",
            "Lu", "Hf", "Ta", "W", "Re", "Os", "Ir", "Pt", "Au", "Hg", "Tl", "Pb", "Bi", "Po", "At", "Rn",
            "Fr", "Ra", "Ac", "Th", "Pa", "U", "Np", "Pu", "Am", "Cm", "Bk", "Cf", "Es", "Fm", "Md", "No", "Lr",
            "Rf", "Db", "Sg", "Bh", "Hs", "Mt"
        ]
        
        self.atom_masses = [
            1.0079, 4.0026, 6.941, 9.0122, 10.811, 12.0107, 14.0067, 15.9994, 18.9984, 20.1797, 22.9897, 24.305,
            26.9815, 28.0855, 30.9738, 32.065, 35.453, 39.948, 39.0983, 40.078, 44.9559, 47.867, 50.9415, 51.9961,
            54.938, 55.845, 58.9332, 58.6934, 63.546, 65.39, 69.723, 72.64, 74.9216, 78.96, 79.904, 83.8,
            85.4678, 87.62, 88.9059, 91.224, 92.9064, 95.94, 98, 101.07, 102.906, 106.42, 107.868, 112.411,
            114.818, 118.71, 121.76, 127.6, 126.904, 131.293, 132.905, 137.327, 138.905, 140.116, 140.908, 144.24,
            145, 150.36, 151.964, 157.25, 158.925, 162.5, 164.93, 167.259, 168.934, 173.04, 174.967, 178.49,
            180.948, 183.84, 186.207, 190.23, 192.217, 195.078, 196.966, 200.59, 204.383, 207.2, 208.98, 209,
            210, 222, 223, 226, 227, 232.038, 231.036, 238.029, 237, 244, 243, 247, 247, 251, 252, 257, 258, 259,
            262, 261, 262, 266, 264, 277, 268
        ]
        
        # Create dictionary mapping symbols to masses
        self.atoms = dict(zip(self.atom_symbols, self.atom_masses))
        
        # International Tables space groups
        self.int_tables = [
            "P1", "P-1",
            "P2", "P2(1)", "C2", "Pm", "Pc", "Cm", "Cc", "P2/m", "P2(1)/m", "C2/m", "P2/c", "P2(1)/c", "C2/c",
            "P222", "P222(1)", "P2(1)2(1)2", "P2(1)2(1)2(1)", "C222(1)", "C222", "F222", "I222", "I2(1)2(1)2(1)",
            "Pmm2", "Pmc2(1)", "Pcc2", "Pma2", "Pca2(1)", "Pnc2", "Pmn2(1)", "Pba2", "Pna2(1)", "Pnn2",
            "Cmm2", "Cmc2(1)", "Ccc2", "Amm2", "Abm2", "Ama2", "Aba2", "Fmm2", "Fdd2", "Imm2", "Iba2", "Ima2",
            "Pmmm", "Pnnn", "Pccm", "Pban", "Pmma", "Pnna", "Pmna", "Pcca", "Pbam", "Pccn", "Pbcm", "Pnnm",
            "Pmmn", "Pbcn", "Pbca", "Pnma", "Cmcm", "Cmca", "Cmmm", "Cccm", "Cmma", "Ccca", "Fmmm", "Fddd",
            "Immm", "Ibam", "Ibca", "Imma",
            "P4", "P4(1)", "P4(2)", "P4(3)", "I4", "I4(1)", "P-4", "I-4", "P4/m", "P4(2)/m", "P4/n", "P4(2)/n",
            "I4/m", "I4(1)/a", "P422", "P42(1)2", "P4(1)22", "P4(1)2(1)2", "P4(2)22", "P4(2)2(1)2", "P4(3)22",
            "P4(3)2(1)2", "I422", "I4(1)22", "P4mm", "P4bm", "P4(2)cm", "P4(2)nm", "P4cc", "P4nc", "P4(2)mc",
            "P4(2)bc", "I4mm", "I4cm", "I4(1)md", "I4(1)cd", "P-42m", "P-42c", "P-42(1)m", "P-42(1)c",
            "P-4m2", "P-4c2", "P-4b2", "P-4n2", "I-4m2", "I-4c2", "I-42m", "I-42d", "P4/mmm", "P4/mcc",
            "P4/nbm", "P4/nnc", "P4/mbm", "P4/mnc", "P4/nmm", "P4/ncc", "P4(2)/mmc", "P4(2)/mcm", "P4(2)/nbc",
            "P4(2)/nnm", "P4(2)/mbc", "P4(2)/mnm", "P4(2)/nmc", "P4(2)/ncm", "I4/mmm", "I4/mcm", "I4(1)/amd", "I4(1)/acd",
            "P3", "P3(1)", "P3(2)", "R3", "P-3", "R-3", "P312", "P321", "P3(1)12", "P3(1)21", "P3(2)12", "P3(2)21",
            "R32", "P3m1", "P31m", "P3c1", "P31c", "R3m", "R3c", "P-31m", "P-31c", "P-3m1", "P-3c1", "R-3m", "R-3c",
            "P6", "P6(1)", "P6(5)", "P6(2)", "P6(4)", "P6(3)", "P-6", "P6/m", "P6(3)/m", "P622", "P6(1)22",
            "P6(5)22", "P6(2)22", "P6(4)22", "P6(3)22", "P6mm", "P6cc", "P6(3)cm", "P6(3)mc", "P-6m2", "P-6c2",
            "P-62m", "P-62c", "P6/mmm", "P6/mcc", "P6(3)/mcm", "P6(3)/mmc",
            "P23", "F23", "I23", "P2(1)3", "I2(1)3", "Pm-3", "Pn-3", "Fm-3", "Fd-3", "Im-3", "Pa-3", "Ia-3",
            "P432", "P4(2)32", "F432", "F4(1)32", "I432", "P4(3)32", "P4(1)32", "I4(1)32", "P-43m", "F4-3m",
            "I-43m", "P-43n", "F-43c", "I-43d", "Pm-3m", "Pn-3n", "Pm-3n", "Pn-3m", "Fm-3m", "Fm-3c",
            "Fd-3m", "Fd-3c", "Im-3m", "Ia-3d"
        ]
        
        # CIF keywords and their synonyms
        self.keywords = {
            "_cell_length_a": ["_cell_length_a"],
            "_cell_length_b": ["_cell_length_b"],
            "_cell_length_c": ["_cell_length_c"],
            "_cell_angle_alpha": ["_cell_angle_alpha"],
            "_cell_angle_beta": ["_cell_angle_beta"],
            "_cell_angle_gamma": ["_cell_angle_gamma"],
            "_atom_site_type_symbol": ["_atom_site_type_symbol"],
            "_atom_site_fract_x": ["_atom_site_fract_x"],
            "_atom_site_fract_y": ["_atom_site_fract_y"],
            "_atom_site_fract_z": ["_atom_site_fract_z"],
            "_symmetry_equiv_pos_as_xyz": ["_symmetry_equiv_pos_as_xyz", "_space_group_symop_operation_xyz"],
            "_symmetry_cell_setting": ["_symmetry_cell_setting", "_space_group_crystal_system"],
            "_symmetry_Int_Tables_number": ["_symmetry_Int_Tables_number", "_space_group_IT_number"]
        }
        
        # Initialize variables
        self.reset_variables()
    
    def reset_variables(self):
        """Reset all parsing variables"""
        self.var2 = {}  # For single-line variables
        self.arrays = {}  # For loop variables
        self.loop_vars = []
        self.loop_switch = 0
        self.natom = 0
        self.nsymm = 0
        self.totatom = 0
        self.save_symbols = []
        self.save_x = []
        self.save_y = []
        self.save_z = []
    
    def parse_field(self, line, field_num):
        """Parse a specific field from a line, handling quoted strings"""
        line = line.strip() + " "
        fields = []
        i = 0
        
        while i < len(line):
            # Skip leading spaces
            while i < len(line) and line[i] == ' ':
                i += 1
            
            if i >= len(line):
                break
                
            # Check for quoted string
            if line[i] == "'":
                i += 1  # Skip opening quote
                start = i
                while i < len(line) and line[i] != "'":
                    i += 1
                fields.append(line[start:i])
                if i < len(line):
                    i += 1  # Skip closing quote
            else:
                # Regular field
                start = i
                while i < len(line) and line[i] != ' ':
                    i += 1
                fields.append(line[start:i])
        
        if field_num <= len(fields):
            return fields[field_num - 1]
        return ""
    
    def search_keyword(self, keyword):
        """Search for a keyword in the recognized keywords"""
        for main_key, synonyms in self.keywords.items():
            if keyword in synonyms:
                return main_key
        return None
    
    def evaluate_expression(self, expr):
        """Safely evaluate a mathematical expression"""
        try:
            # Replace common mathematical expressions
            expr = expr.replace("--", "+")
            # Only allow basic mathematical operations
            allowed_chars = set("0123456789+-*/().x y z")
            if not all(c in allowed_chars for c in expr.replace(" ", "")):
                return float(expr)
            return eval(expr)
        except:
            try:
                return float(expr)
            except:
                return 0.0
    
    def norma(self, x, y, z, expr_str):
        """Normalize coordinates by applying symmetry operations"""
        expr = expr_str.replace("x", str(x)).replace("y", str(y)).replace("z", str(z))
        val = self.evaluate_expression(expr)
        
        # Bring value to [0, 1) range
        while val < 0.0:
            val += 1.0
        while val >= 1.0:
            val -= 1.0
        return val
    
    def find_lattice(self, a, b, c, alpha, beta, gamma):
        """Find the Bravais lattice name from lattice parameters"""
        thr = 1e-4
        
        if (abs(alpha - 90.0) < thr) and (abs(gamma - 90.0) < thr):
            if abs(beta - 90.0) < thr:
                if (abs(a - b) < thr) and (abs(a - c) < thr):
                    return "cubic"
                elif abs(a - b) < thr:
                    return "tetragonal"
                else:
                    return "orthorhombic"
            else:
                return "monoclinic"
        elif (abs(alpha - 90.0) < thr) and (abs(beta - 90.0) < thr) and (abs(gamma - 120.0) < thr):
            return "hexagonal"
        elif (abs(alpha - beta) < thr) and (abs(alpha - gamma) < thr) and (abs(a - b) < thr) and (abs(a - c) < thr):
            return "rhombohedral"
        else:
            return "triclinic"
    
    def find_ibrav(self, spacegroup, lattice_type):
        """Find the ibrav parameter for Quantum Espresso"""
        ibrav = 0
        if not spacegroup:
            return 0
            
        primitive = spacegroup.startswith("P")
        bodycentered = spacegroup.startswith("I")
        facecentered = spacegroup.startswith("F")
        basecentered = spacegroup.startswith("C")
        
        if lattice_type == "cubic":
            if primitive:
                ibrav = 1
            elif facecentered:
                ibrav = 2
            elif bodycentered:
                ibrav = 3
        elif lattice_type == "tetragonal":
            if primitive:
                ibrav = 6
            elif bodycentered:
                ibrav = 7
        elif lattice_type == "orthorhombic":
            if primitive:
                ibrav = 8
            elif basecentered:
                ibrav = 9
            elif facecentered:
                ibrav = 10
            elif bodycentered:
                ibrav = 11
        elif lattice_type == "monoclinic":
            if primitive:
                ibrav = -12
            elif basecentered:
                ibrav = 13
        elif lattice_type == "triclinic":
            ibrav = 14
        elif lattice_type == "hexagonal":
            ibrav = 4
        elif lattice_type == "rhombohedral":
            if primitive:
                ibrav = 4
            else:
                ibrav = 5
        
        return ibrav
    
    def parse_cif(self, filename):
        """Parse a CIF file"""
        self.reset_variables()
        
        with open(filename, 'r') as f:
            lines = f.readlines()
        
        jvar = 0
        
        for line in lines:
            line = line.strip()
            
            # Skip comments
            if line.startswith('#') or line.startswith(';') or not line:
                continue
            
            # Handle loop
            if line.startswith('loop_'):
                self.loop_switch = 1
                self.loop_vars = []  # Reset loop variables
                continue
            
            # Handle CIF keywords (starting with _)
            if line.startswith('_'):
                parts = line.split(None, 1)
                keyword = parts[0]
                
                if self.loop_switch == 1:
                    # In a loop, collect variable names
                    main_keyword = self.search_keyword(keyword)
                    if main_keyword:
                        self.loop_vars.append(main_keyword)
                    else:
                        self.loop_vars.append(keyword)
                else:
                    # Single variable assignment
                    self.loop_switch = 0
                    main_keyword = self.search_keyword(keyword)
                    if main_keyword and len(parts) > 1:
                        self.var2[main_keyword] = parts[1]
                    elif len(parts) > 1:
                        # Store unrecognized keywords as well
                        self.var2[keyword] = parts[1]
                continue
            
            # Handle data lines (not starting with _ or loop_)
            if not line.startswith('_') and not line.startswith('loop_') and self.loop_vars:
                if self.loop_switch == 1 or self.loop_switch == 2:
                    self.loop_switch = 2
                    
                    # Parse data according to loop variables
                    for i, var in enumerate(self.loop_vars):
                        value = self.parse_field(line, i + 1)
                        if var not in self.arrays:
                            self.arrays[var] = []
                        self.arrays[var].append(value)
                    
                    # Count atoms and symmetry operations
                    has_symbol = "_atom_site_type_symbol" in self.loop_vars
                    has_x = "_atom_site_fract_x" in self.loop_vars
                    if has_symbol and has_x:
                        self.natom += 1
                    
                    if "_symmetry_equiv_pos_as_xyz" in self.loop_vars:
                        self.nsymm += 1
                else:
                    self.loop_switch = 0
            elif not line.startswith('_') and not line.startswith('loop_'):
                # Reset loop when we encounter non-loop data
                self.loop_switch = 0
                self.loop_vars = []
    
    def generate_qe_input(self, file_prefix, filename, do_ibrav=False, sg=0, home_dir=".", occupations='smearing', smearing='gaussian'):
        """Generate Quantum Espresso input file"""
        # Extract cell parameters with better error handling
        try:
            a = float(self.var2.get("_cell_length_a", "1.0"))
        except (ValueError, TypeError):
            a = 1.0
        try:
            b = float(self.var2.get("_cell_length_b", "1.0"))
        except (ValueError, TypeError):
            b = 1.0
        try:
            c = float(self.var2.get("_cell_length_c", "1.0"))
        except (ValueError, TypeError):
            c = 1.0
        try:
            alpha = float(self.var2.get("_cell_angle_alpha", "90.0"))
        except (ValueError, TypeError):
            alpha = 90.0
        try:
            beta = float(self.var2.get("_cell_angle_beta", "90.0"))
        except (ValueError, TypeError):
            beta = 90.0
        try:
            gamma = float(self.var2.get("_cell_angle_gamma", "90.0"))
        except (ValueError, TypeError):
            gamma = 90.0
        
        # Convert angles to radians
        alphar = math.radians(alpha)
        betar = math.radians(beta)
        gammar = math.radians(gamma)
        
        # Determine lattice type
        lattice_type = self.find_lattice(a, b, c, alpha, beta, gamma)
        
        # Get space group information
        tmp_spacegroup = (self.var2.get("_symmetry_space_group", "") or 
                         self.var2.get("_symmetry_space_group_name_H-M", ""))
        tmp_table_number = self.var2.get("_symmetry_Int_Tables_number", "0")
        
        try:
            table_number = int(float(tmp_table_number))
            if table_number > 0 and table_number <= len(self.int_tables):
                tmp_spacegroup = self.int_tables[table_number - 1]
        except:
            table_number = 0
        
        ibrav = self.find_ibrav(tmp_spacegroup, lattice_type)
        
        # Calculate K-points
        kp_x = max(1, int(1.0 / (a * self.separation) + 0.5))
        kp_y = max(1, int(1.0 / (b * self.separation) + 0.5))
        kp_z = max(1, int(1.0 / (c * self.separation) + 0.5))
        
        # Get unique atom types
        atom_types = []
        type_atom = {}
        
        if "_atom_site_type_symbol" in self.arrays:
            for symbol in self.arrays["_atom_site_type_symbol"]:
                if symbol not in type_atom:
                    type_atom[symbol] = True
                    atom_types.append(symbol)
        
        ntyp = len(atom_types)
        
        # Generate symmetry-equivalent positions
        if "_atom_site_type_symbol" in self.arrays:
            self.generate_symmetry_positions()
        
        # Start generating output
        output = []
        output.append("&CONTROL")
        output.append(f"                       title = 'Generated from CIF file'")
        output.append("                 calculation = 'scf'")
        output.append("                restart_mode = 'from_scratch'")
        output.append("                      outdir = './tmp'")
        output.append(f"                  pseudo_dir = '{home_dir}'")
        output.append(f"                      prefix = '{file_prefix}'")
        output.append("                   verbosity = 'high'")
        output.append("               etot_conv_thr = 1.0D-6")
        output.append("               forc_conv_thr = 1.0D-6")
        # output.append("                       nstep = 400")
        output.append("                     tstress = .true.")
        output.append("                     tprnfor = .true.")
        output.append(" /")
        output.append(" &SYSTEM")
        
        if sg != 2:
            if do_ibrav and ibrav != 0:
                output.append(f"                       ibrav = {ibrav}")
                output.append(f"                   celldm(1) = {a/self.bohr:19.14f}")
                
                # Add additional celldm parameters based on ibrav
                if ibrav in [4, 6, 7]:
                    output.append(f"                   celldm(3) = {c/a:19.14f}")
                elif ibrav in [5, -5]:
                    output.append(f"                   celldm(4) = {math.cos(alphar):19.14f}")
                elif ibrav == 14:
                    output.append(f"                   celldm(2) = {b/a:19.14f}, celldm(3) = {c/a:19.14f}")
                    output.append(f"                   celldm(4) = {math.cos(alphar):19.14f}")
                    output.append(f"                   celldm(5) = {math.cos(betar):19.14f}")
                    output.append(f"                   celldm(6) = {math.cos(gammar):19.14f}")
                elif ibrav == -12:
                    output.append(f"                   celldm(2) = {b/a:19.14f}, celldm(3) = {c/a:19.14f}")
                    output.append(f"                   celldm(5) = {math.cos(betar):19.14f}")
                elif ibrav == 13:
                    output.append(f"                   celldm(2) = {b/a:19.14f}, celldm(3) = {c/a:19.14f}")
                    output.append(f"                   celldm(4) = {math.cos(gammar):19.14f}")
                elif ibrav in [8, 9, 10, 11]:
                    output.append(f"                   celldm(2) = {b/a:19.14f}, celldm(3) = {c/a:19.14f}")
                elif ibrav == 12:
                    output.append(f"                   celldm(2) = {b/a:19.14f}, celldm(3) = {c/a:19.14f}")
                    output.append(f"                   celldm(4) = {math.cos(gammar):19.14f}")
            else:
                output.append("                       ibrav = 0")
            
            output.append(f"                    lspinorb = .TRUE.")
            output.append(f"                    noncolin = .TRUE.")
            output.append(f"                         nat = {self.totatom}")
            output.append(f"                        ntyp = {ntyp}")
        
        if sg == 2:
            output.append(f"                 space_group = {table_number}")
            output.append("                rhombohedral = .TRUE.")
            output.append("                    uniqueb = .FALSE.")
            output.append("               origin_choice = 1")
            output.append(f"                         nat = {self.natom}")
            output.append(f"                        ntyp = {ntyp}")
        
        output.append("                     ecutwfc = 50")
        output.append("                     ecutrho = 400")
        output.append(f"                 occupations = '{occupations}'")
        output.append("                   degauss   = 0.01 ")
        output.append(f"                    smearing = '{smearing}'")
        output.append(" /")
        output.append(" &ELECTRONS")
        output.append("            electron_maxstep = 200")
        output.append("                    conv_thr = 1.0D-9")
        output.append("                 mixing_beta = 0.3")
        output.append(" /")
        output.append("")
        output.append("ATOMIC_SPECIES")
        
        # Print atomic species
        for atom_type in atom_types:
            
            # Clean atom_type by removing numbers and +/- signs
            clean_atom_type = re.sub(r'[0-9+\-]', '', atom_type)
            # Search for UPF file in home_dir
            upf_file = f"{clean_atom_type}.rel.upf"  # default fallback
            try:
                files_in_dir = os.listdir(home_dir)
                for file in files_in_dir:
                    if file.lower().startswith(f"{clean_atom_type}.rel".lower()) and file.lower().endswith('.upf'):
                        upf_file = file
                        break
            except OSError:
                # If directory doesn't exist or can't be read, use default
                pass
            mass = self.atoms.get(clean_atom_type, 1.0)
            output.append(f"  {clean_atom_type:>3s}  {mass:14.10f}  {upf_file}")

        # Print atomic positions
        if sg != 2:
            output.append("")
            output.append("ATOMIC_POSITIONS crystal")
            for i in range(self.totatom):
                # Remove numbers and +, - from symbol       
                self.save_symbols[i] = re.sub(r'[0-9+\-]', '', self.save_symbols[i])
                output.append(f"{self.save_symbols[i]:>2s}   {self.save_x[i]:19.14f}   {self.save_y[i]:19.14f}   {self.save_z[i]:19.14f}")
        
        if sg == 2:
            output.append("")
            output.append("ATOMIC_POSITIONS crystal_sg")
            for i in range(self.natom):
                if i < len(self.save_symbols):  
                    # Remove numbers and +, - from symbol       
                    self.save_symbols[i] = re.sub(r'[0-9+\-]', '', self.save_symbols[i])
                    output.append(f"{self.save_symbols[i]:>2s}   {self.save_x[i]:19.14f}    {self.save_y[i]:19.14f}    {self.save_z[i]:19.14f}")
        
        # Print K-points
        output.append("")
        output.append("K_POINTS automatic")
        output.append(f"{kp_x}  {kp_y}  {kp_z}   0 0 0")
        
        # Print cell parameters if needed
        if not do_ibrav or sg == 2:
            # Calculate cell vectors
            cell_px = [a, 0.0, 0.0]
            cell_py = [b * math.cos(gammar), b * math.sin(gammar), 0.0]
            cell_pz = [
                c * math.cos(betar),
                c * (math.cos(alphar) - math.cos(betar) * math.cos(gammar)) / math.sin(gammar),
                c * math.sqrt(1.0 - math.cos(alphar)**2 - math.cos(betar)**2 - math.cos(gammar)**2 + 
                             2 * math.cos(alphar) * math.cos(betar) * math.cos(gammar)) / math.sin(gammar)
            ]
            
            output.append("")
            output.append("CELL_PARAMETERS {bohr}")
            for i in range(3):
                if i == 0:
                    output.append(f"  {cell_px[0]/self.bohr:19.14f}   {cell_px[1]/self.bohr:19.14f}   {cell_px[2]/self.bohr:19.14f}")
                elif i == 1:
                    output.append(f"  {cell_py[0]/self.bohr:19.14f}   {cell_py[1]/self.bohr:19.14f}   {cell_py[2]/self.bohr:19.14f}")
                else:
                    output.append(f"  {cell_pz[0]/self.bohr:19.14f}   {cell_pz[1]/self.bohr:19.14f}   {cell_pz[2]/self.bohr:19.14f}")
        
        output.append("")
        output.append("")
        
        return '\n'.join(output)
    
    def generate_symmetry_positions(self):
        """Generate all symmetry-equivalent atomic positions"""
        self.totatom = 0
        self.save_symbols = []
        self.save_x = []
        self.save_y = []
        self.save_z = []
        
        if ("_atom_site_type_symbol" not in self.arrays or 
            "_atom_site_fract_x" not in self.arrays or
            "_atom_site_fract_y" not in self.arrays or
            "_atom_site_fract_z" not in self.arrays):
            return
        
        # Get symmetry operations
        symm_ops = self.arrays.get("_symmetry_equiv_pos_as_xyz", ["x,y,z"])
        
        # For each atom
        for i in range(self.natom):
            if i >= len(self.arrays["_atom_site_type_symbol"]):
                break
                
            symbol = self.arrays["_atom_site_type_symbol"][i]
            try:
                f_x = float(self.arrays["_atom_site_fract_x"][i])
                f_y = float(self.arrays["_atom_site_fract_y"][i])
                f_z = float(self.arrays["_atom_site_fract_z"][i])
            except (ValueError, TypeError, IndexError):
                continue
            
            # Apply each symmetry operation
            for symm_op in symm_ops:
                parts = symm_op.split(',')
                if len(parts) != 3:
                    print(f"Error in _symmetry_equiv_pos_as_xyz. Number of fields != 3: {parts}")
                    continue
                
                # Apply symmetry operation
                p_x = self.norma(f_x, f_y, f_z, parts[0].strip())
                p_y = self.norma(f_x, f_y, f_z, parts[1].strip())
                p_z = self.norma(f_x, f_y, f_z, parts[2].strip())
                
                # Check if this position already exists
                exists = False
                for j in range(self.totatom):
                    if (abs(p_x - self.save_x[j]) < self.tol and 
                        abs(p_y - self.save_y[j]) < self.tol and 
                        abs(p_z - self.save_z[j]) < self.tol):
                        exists = True
                        break
                
                if not exists:
                    self.save_symbols.append(symbol)
                    self.save_x.append(p_x)
                    self.save_y.append(p_y)
                    self.save_z.append(p_z)
                    self.totatom += 1

def run_pw_calculation(input_file, output_file, num_cores):
    """Run pw.x calculation using mpirun, with direct file IO for stdin/stdout."""
    try:
        command = ["mpirun", "-np", str(num_cores), "pw.x"]
        env = os.environ.copy()
        with open(input_file, 'r') as fin, open(output_file, 'w') as fout:
            print(f"Running: {' '.join(command)} < {input_file} > {output_file}")
            result = subprocess.run(command, stdin=fin, stdout=fout, stderr=subprocess.PIPE, text=True, env=env)
        if result.returncode == 0:
            print(f"✓ Calculation completed successfully")
            return True
        else:
            print(f"✗ Calculation failed with return code {result.returncode}")
            if result.stderr:
                print(f"Error: {result.stderr}")
            return False
    except Exception as e:
        print(f"Error running calculation: {e}")
        return False

def run_bands_calculation(input_file, output_file, num_cores):
    """Run bands.x calculation using mpirun, with direct file IO for stdin/stdout."""
    try:
        command = ["mpirun", "-np", str(num_cores), "bands.x"]
        env = os.environ.copy()
        with open(input_file, 'r') as fin, open(output_file, 'w') as fout:
            print(f"Running: {' '.join(command)} < {input_file} > {output_file}")
            result = subprocess.run(command, stdin=fin, stdout=fout, stderr=subprocess.PIPE, text=True, env=env)
        if result.returncode == 0:
            print(f"✓ Calculation completed successfully")
            return True
        else:
            print(f"✗ Calculation failed with return code {result.returncode}")
            if result.stderr:
                print(f"Error: {result.stderr}")
            return False
    except Exception as e:
        print(f"Error running calculation: {e}")
        return False
    
def run_dos_calculation(input_file, output_file, num_cores):
    """Run dos.x calculation using mpirun, with direct file IO for stdin/stdout."""
    try:
        command = ["mpirun", "-np", str(num_cores), "dos.x"]
        env = os.environ.copy()
        with open(input_file, 'r') as fin, open(output_file, 'w') as fout:
            print(f"Running: {' '.join(command)} < {input_file} > {output_file}")
            result = subprocess.run(command, stdin=fin, stdout=fout, stderr=subprocess.PIPE, text=True, env=env)
        if result.returncode == 0:
            print(f"✓ Calculation completed successfully")
            return True
        else:
            print(f"✗ Calculation failed with return code {result.returncode}")
            if result.stderr:
                print(f"Error: {result.stderr}")
            return False
    except Exception as e:
        print(f"Error running calculation: {e}")
        return False
    
def run_projwfc_calculation(input_file, output_file, num_cores):
    """Run projwfc.x calculation using mpirun, with direct file IO for stdin/stdout."""
    try:
        command = ["mpirun", "-np", str(num_cores), "projwfc.x"]
        env = os.environ.copy()
        with open(input_file, 'r') as fin, open(output_file, 'w') as fout:
            print(f"Running: {' '.join(command)} < {input_file} > {output_file}")
            result = subprocess.run(command, stdin=fin, stdout=fout, stderr=subprocess.PIPE, text=True, env=env)
        if result.returncode == 0:
            print(f"✓ Calculation completed successfully")
            return True
        else:
            print(f"✗ Calculation failed with return code {result.returncode}")
            if result.stderr:
                print(f"Error: {result.stderr}")
            return False
    except Exception as e:
        print(f"Error running calculation: {e}")
        return False
    
def run_sumpdos_calculation(input, output):
    """Run sumpdos.x calculation using mpirun, with direct file IO for stdin/stdout."""
    command = [f"sumpdos.x {input} > {output}"]
    env = os.environ.copy()
    result = subprocess.run(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, env=env)
    if result.returncode == 0:
        return True
    else:
        # Print stderr if there was an error
        if result.stderr:
            print(f"Error running sumpdos.x: {result.stderr.strip()}")
        if os.path.isfile(output):
            os.remove(output)
        return False

def run_elastic_calculation(input_file, output_file, num_cores):
    """Run thermo_pw.x calculation using mpirun, with direct file IO for stdin/stdout and also print output to terminal."""
    try:
        command = ["mpirun", "-np", str(num_cores), "thermo_pw.x"]
        env = os.environ.copy()
        with open(input_file, 'r') as fin, open(output_file, 'w') as fout:
            print(f"Running: {' '.join(command)} < {input_file} > {output_file}")
            # Capture output and write to both file and terminal
            try:
                process = subprocess.Popen(command, stdin=fin, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, env=env)
            except FileNotFoundError as fnf:
                print("Error: thermo_pw.x command not found. Please install thermo_pw and ensure it is in your PATH.")
                return False
            for line in process.stdout:
                print(line, end='')      # Print to terminal
                fout.write(line)         # Write to file
            process.wait()
        if process.returncode == 0:
            print(f"✓ Calculation completed successfully")
            return True
        else:
            print(f"✗ Calculation failed with return code {process.returncode}")
            return False
    except Exception as e:
        print(f"Error running calculation: {e}")
        return False

def extract_total_energy(output_file):
    """
    Extract total energy from pw.x output file.
    Looks for lines starting with '!' which contain the total energy.
    
    Args:
        output_file (str): Path to the output file
        
    Returns:
        float: Total energy value or None if not found
    """
    try:
        with open(output_file, 'r') as f:
            content = f.read()
        
        # Look for lines starting with '!' that contain total energy
        pattern = r'!\s+total energy\s*=\s*(-?\d+\.\d+)\s*Ry'
        matches = re.findall(pattern, content)
        
        if matches:
            return float(matches[-1])
        else:
            print(f"Warning: Total energy not found in {output_file}")
            return None
            
    except Exception as e:
        print(f"Error reading {output_file}: {e}")
        return None

# This function extracts the Fermi energy from the scf output file
def fermi_energy(scfout, key='Fermi'):
    Fermi_E = 'None'
    if scfout:
        f = open(scfout, 'r')
        for line in f:
            if key in line:
                Fermi_E = float(line.strip().split()[4])
        f.close()
    return Fermi_E

# This function gets the high symmetry points from the output of bands.x
def hsym_pts(bandsout):
    hspts = np.zeros(0)
    if bandsout:
        f = open(bandsout,'r')
        for i in f:
            if "high-symmetry" in i:
                hspts = np.append(hspts,float(i.split()[-1]))
        f.close()
    return hspts

# This function gets the high symmetry labels from pw.x (with 'calculation=bands/nscf')
def hsym_labels(nscf=None):
    hslabels = []
    if nscf:
        f = open(nscf, 'r')
        flag = False  # used to know if the K-POINTS namelist has been reached
        for line in f:
            if 'K_POINTS' in line.upper():
                flag = True
            # check if it is a bandstructure calculation
            if "calculation" in line.lower():
                if ('nscf' not in line.lower()) and ('bands' not in line.lower()):
                    print ("This does not seem to be a bandstructure calculation...Aborting")
                    sys.exit(0)
            if flag:
                lst = line.strip().split()
                if len(lst) == 2:
                    hslabels.append(lst[0])
        f.close()
        if hslabels:
            hslabels = hslabels[1:]
    return hslabels

def generate_csv_file(gnufile):
    # Read the gnufile and parse sections
    sections = []
    current_section = []
    
    with open(gnufile, 'r') as f:
        for line in f:
            line = line.strip()
            if line == '':  # Empty line indicates new section
                if current_section:
                    sections.append(current_section)
                    current_section = []
            else:
                # Parse K-point and Energy values
                parts = line.split()
                if len(parts) == 2:
                    k_point = float(parts[0])
                    energy = float(parts[1])
                    current_section.append((k_point, energy))
        
        # Add the last section if it exists
        if current_section:
            sections.append(current_section)
    
    if not sections:
        print("No data found in the file.")
        return
    
    # Extract K-points from the first section (they should be the same across all sections)
    k_points = [point[0] for point in sections[0]]
    
    # Create CSV filename based on gnufile name
    csv_filename = gnufile.replace('.gnu', '.csv').replace('.bands', '_bands')
    if csv_filename == gnufile:  # If no replacement occurred
        csv_filename = gnufile + '.csv'
    
    # Write CSV file
    with open(csv_filename, 'w', newline='') as csvfile:
        writer = csv.writer(csvfile)
        
        # Write header
        header = ['K_points'] + [f'Energy_Band_{i+1}' for i in range(len(sections))]
        writer.writerow(header)
        
        # Write data rows
        for i, k_point in enumerate(k_points):
            row = [k_point]
            # Add energy values from each section for this K-point
            for section in sections:
                if i < len(section):
                    row.append(section[i][1])  # Energy value
                else:
                    row.append('')  # Empty if section doesn't have this K-point
            writer.writerow(row)
    
    print(f"CSV file created: {csv_filename}")
    print(f"Number of K-points: {len(k_points)}")
    print(f"Number of energy bands: {len(sections)}")
    
    return csv_filename

def plot_band_structure(csv_filename, hsym_pts=None, hsym_labels=None, fermi_energy=None, y_range=None):
    """
    Plot band structure from CSV file
    
    Parameters:
    csv_filename: Path to the CSV file containing band data
    hsym_pts: High symmetry points for vertical lines (optional)
    hsym_labels: Labels for high symmetry points (optional)
    fermi_energy: Fermi energy to draw horizontal line (optional)
    y_range: Tuple (ymin, ymax) for y-axis range (optional)
    """
    # Read CSV data
    data = []
    with open(csv_filename, 'r') as f:
        reader = csv.reader(f)
        header = next(reader)  # Skip header
        for row in reader:
            data.append([float(val) if val else np.nan for val in row])
    
    data = np.array(data)
    k_points = data[:, 0]
    energy_bands = data[:, 1:]  # All energy columns
    
    # Create the plot
    plt.figure(figsize=(10, 8))
    
    # Plot each energy band
    num_bands = energy_bands.shape[1]
    for i in range(num_bands):
        plt.plot(k_points, energy_bands[:, i], 'b-', linewidth=0.8, alpha=0.7)
    
    # Add high symmetry points as vertical lines
    if hsym_pts is not None and len(hsym_pts) > 0:
        for pt in hsym_pts:
            plt.axvline(x=pt, color='k', linestyle='--', alpha=0.5)
    
    # Draw Fermi level at y=0
    plt.axhline(y=0, color='r', linestyle='--', label='Fermi Level (0 eV)')
    # Show Fermi energy in legend (but don't draw a line for it)
    if fermi_energy is not None:
        plt.plot([], [], ' ', label=f'Fermi Energy = {fermi_energy:.3f} eV')
    plt.legend()
    
    # Customize the plot
    plt.xlabel('K-points', fontsize=12)
    plt.ylabel('Energy (eV)', fontsize=12)
    plt.title('Electronic Band Structure', fontsize=14)
    plt.grid(True, alpha=0.3)
    
    # Set y-axis range if provided
    if y_range is not None:
        plt.ylim(y_range)
    
    # Add high symmetry labels on x-axis
    if hsym_pts is not None and hsym_labels is not None:
        if len(hsym_pts) == len(hsym_labels):
            plt.xticks(hsym_pts, hsym_labels)
        else:
            print("Warning: Number of high symmetry points and labels don't match")
    
    plt.tight_layout()
    
    # Save the plot
    plot_filename = csv_filename.replace('.csv', '_band_structure.png')
    plt.savefig(plot_filename, dpi=300, bbox_inches='tight')
    print(f"Band structure plot saved as: {plot_filename}")
    
    plt.show()
    return plot_filename

def plot_bands_from_gnu(scfout, nscfin, bandsout, gnufile):
    # Example usage
    fermi_energy_value = fermi_energy(scfout)  # Example usage, replace with actual scf output file path
    hsym_points = hsym_pts(bandsout=bandsout)  # Example usage, replace with actual bands output file path
    hsym_point_labels = hsym_labels(nscf=nscfin)  # Example usage, replace with actual nscf file path
    print("High symmetry labels:", hsym_point_labels)

    csv_file = generate_csv_file(gnufile=gnufile)

    # Plot the band structure
    plot_file = plot_band_structure(csv_file, hsym_pts=hsym_points, hsym_labels=hsym_point_labels, 
                    fermi_energy=fermi_energy_value, y_range=(-10, 20))
    return plot_file

def check_convergence(): 
    output_dir = "SOC.convergence"

    # Ask user for occupations and smearing with defaults
    print("\nQuantum Espresso calculation parameters:")
    occupations_input = input("Enter occupations (default: smearing): ").strip()
    occupations = occupations_input if occupations_input else 'smearing'
    
    smearing_input = input("Enter smearing type (default: gaussian): ").strip()
    smearing = smearing_input if smearing_input else 'gaussian'
    
    print(f"Using occupations = '{occupations}' and smearing = '{smearing}'\n")
    
    # Save current working directory
    original_cwd = os.getcwd()

    # Create converter and process file
    converter = CIF2QESOC()
    
    try:
        converter.parse_cif(filename)
        
        # Track previous k-point combinations to avoid duplicates
        previous_kpoints = set()
        generated_files = []
        
        # Generate multiple outputs with different separation values
        separation = 0.06
        file_count = 0
        
        # Change to the outdir directory, create if it doesn't exist
        if not os.path.isdir(output_dir):
            os.makedirs(output_dir, exist_ok=True)
        os.chdir(output_dir)
        
        # First pass: generate all input files
        print("Generating input files...")
        while separation >= 0.005:
            # Set the separation value for this iteration
            converter.separation = separation
            
            # Calculate k-points for this separation to check conditions
            a = float(converter.var2.get("_cell_length_a", "1.0"))
            b = float(converter.var2.get("_cell_length_b", "1.0"))
            c = float(converter.var2.get("_cell_length_c", "1.0"))
            
            kp_x = max(1, int(1.0 / (a * separation) + 0.5))
            kp_y = max(1, int(1.0 / (b * separation) + 0.5))
            kp_z = max(1, int(1.0 / (c * separation) + 0.5))
            
            # Skip if any k-point exceeds 24
            if kp_x > 24 or kp_y > 24 or kp_z > 24:
                print(f"Skipping separation {separation:.3f}: k-points ({kp_x}, {kp_y}, {kp_z}) exceed 24")
                separation -= 0.005
                continue
            
            # Skip if this k-point combination was already generated
            kpoint_tuple = (kp_x, kp_y, kp_z)
            if kpoint_tuple in previous_kpoints:
                print(f"Skipping separation {separation:.3f}: k-points ({kp_x}, {kp_y}, {kp_z}) already generated")
                separation -= 0.005
                continue
            
            # Add this k-point combination to the set
            previous_kpoints.add(kpoint_tuple)
            
            # Generate output for this separation
            output = converter.generate_qe_input(file_prefix, filename, do_ibrav, sg, home_dir, occupations, smearing)
            
            # Create output filename
            output_filename = f"{file_prefix}.{kp_x}x{kp_y}x{kp_z}.scf.in"
            
            # Write output to file
            with open(output_filename, 'w') as f:
                f.write(output)
            
            generated_files.append(output_filename)
            print(f"Generated {output_filename} with separation {separation:.3f} and k-points ({kp_x}, {kp_y}, {kp_z})")
            file_count += 1
            
            # Reduce separation for next iteration
            separation -= 0.005
        
        print(f"\nTotal files generated: {file_count}")
        
        # Second pass: run calculations with convergence checking
        print("\nRunning calculations with convergence checking...")
        previous_energies = []
        convergence_count = 0
        convergence_threshold = 0.001
        required_convergence_steps = 3
        
        # Data for plotting
        k_points_data = []
        energy_data = []
        k_point_labels = []
        
        for i, input_file in enumerate(generated_files):
            output_file = input_file.replace('.scf.in', '.scf.out')
            
            # Extract k-point information from filename
            # Format: {file_prefix}.{kp_x}x{kp_y}x{kp_z}.scf.in
            base_name = os.path.basename(input_file)
            k_part = base_name.split('.')[-3]  # Get the kp_x x kp_y x kp_z part
            kp_x, kp_y, kp_z = map(int, k_part.split('x'))
            k_total = kp_x * kp_y * kp_z  # Total number of k-points
            k_label = f"{kp_x}x{kp_y}x{kp_z}"
            
            print(f"\nRunning calculation {i+1}/{len(generated_files)}: {input_file}")
            print(f"K-points: {k_label} (Total: {k_total})")
            
            # Run the calculation
            success = run_pw_calculation(input_file, output_file, num_cores)
            
            if not success:
                print(f"\n✗ FATAL ERROR: Calculation failed for {input_file}")
                print("The pw.x calculation did not complete successfully.")
                print("Please check:")
                print("- Input file syntax and parameters")
                print("- Pseudopotential files availability")
                print("- System resources (memory, disk space)")
                print("- MPI configuration")
                sys.exit(1)
            
            # Extract total energy
            total_energy = extract_total_energy(output_file)
            
            if total_energy is None:
                print(f"\n✗ FATAL ERROR: Could not extract total energy from {output_file}")
                print("The calculation may have completed but the output format is unexpected.")
                print("Please check:")
                print("- Output file exists and is readable")
                print("- Calculation completed without errors")
                print("- Output contains the expected energy line format")
                sys.exit(1)
            
            print(f"Total energy: {total_energy:.8f} Ry")
            
            # Store data for plotting
            k_points_data.append(k_total)
            energy_data.append(total_energy)
            k_point_labels.append(k_label)
            
            # Check convergence
            if len(previous_energies) > 0:
                energy_diff = abs(total_energy - previous_energies[-1])
                print(f"Energy difference from previous: {energy_diff:.8f} Ry")
                
                if energy_diff < convergence_threshold:
                    convergence_count += 1
                    print(f"Convergence criterion met ({convergence_count}/{required_convergence_steps})")
                else:
                    convergence_count = 0
                    print("Convergence criterion not met, resetting counter")
                
                # Check if we have enough consecutive convergent steps
                if convergence_count >= required_convergence_steps:
                    print(f"\n✓ Convergence achieved! Energy difference < {convergence_threshold} Ry for {required_convergence_steps} consecutive calculations.")
                    print(f"Stopping calculations. Remaining files: {len(generated_files) - i - 1}")
                    break
            
            previous_energies.append(total_energy)
        
        if convergence_count < required_convergence_steps:
            print(f"\nCompleted all {len(generated_files)} calculations. Convergence was not achieved with the given threshold.")
        
        print(f"\nSummary:")
        print(f"- Total input files generated: {file_count}")
        print(f"- Calculations completed: {len(previous_energies)}")
        if previous_energies:
            print(f"- Final energy: {previous_energies[-1]:.8f} Ry")
        
        # Create the plot if we have data
        if len(energy_data) > 0:
            print(f"\nCreating energy vs k-points plot...")
            
            # Create sequential x-axis values (1, 2, 3, ...)
            x_values = list(range(1, len(energy_data) + 1))
            
            # Create the plot
            plt.figure(figsize=(12, 8))
            
            # Plot the data points
            plt.plot(x_values, energy_data, 'bo-', linewidth=2, markersize=8, 
                    label='Total Energy vs K-points', markerfacecolor='blue', markeredgecolor='darkblue')
            
            # Add individual point labels
            for i, (x_val, energy, k_label) in enumerate(zip(x_values, energy_data, k_point_labels)):
                plt.annotate(k_label, (x_val, energy), 
                        textcoords="offset points", xytext=(0,10), ha='center',
                        fontsize=9, bbox=dict(boxstyle="round,pad=0.3", facecolor="yellow", alpha=0.7))
            
            # Customize the plot
            plt.xlabel('Calculation Number', fontsize=14, fontweight='bold')
            plt.ylabel('Total Energy (Ry)', fontsize=14, fontweight='bold')
            plt.title(f'Energy Convergence vs K-points for {file_prefix}', fontsize=16, fontweight='bold')
            plt.grid(True, alpha=0.3)
            plt.legend(fontsize=12, loc='best')
            
            # Set axis scaling - no scaling on y-axis, show actual values
            plt.xticks(x_values, fontsize=12)  # Show all calculation numbers
            plt.yticks(fontsize=12)
            
            # Disable any automatic scaling or formatting on y-axis
            ax = plt.gca()
            ax.ticklabel_format(useOffset=False, style='plain')
            ax.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'{x:.6f}'))
            
            # Set minimum y-axis range to 0.5 Ry
            min_energy = min(energy_data)
            max_energy = max(energy_data)
            energy_range = max_energy - min_energy

            # Ensure minimum range of 0.05 Ry
            min_range = 0.05
            if energy_range < min_range:
                # Center the range around the data
                center_energy = (min_energy + max_energy) / 2
                y_min = center_energy - min_range / 2
                y_max = center_energy + min_range / 2
            else:
                # Use actual range with small padding
                padding = energy_range * 0.05  # 5% padding
                y_min = min_energy - padding
                y_max = max_energy + padding
            
            plt.ylim(y_min, y_max)
            
            # Add convergence threshold line if we have multiple points
            if len(energy_data) > 1:
                min_energy = min(energy_data)
                max_energy = max(energy_data)
                energy_range = max_energy - min_energy
                
                # Add horizontal line showing convergence threshold relative to the last energy
                if energy_range > convergence_threshold:
                    last_energy = energy_data[-1]
                    plt.axhline(y=last_energy + convergence_threshold, color='red', linestyle='--', 
                            alpha=0.7, label=f'Convergence threshold (±{convergence_threshold} Ry)')
                    plt.axhline(y=last_energy - convergence_threshold, color='red', linestyle='--', alpha=0.7)
                    plt.legend(fontsize=12, loc='best')
            
            # Add text box with calculation details
            textstr = f'Convergence threshold: {convergence_threshold} Ry\nRequired consecutive steps: {required_convergence_steps}'
            if convergence_count >= required_convergence_steps:
                textstr += f'\nConvergence: ✓ Achieved'
            else:
                textstr += f'\nConvergence: ✗ Not achieved'
            
            props = dict(boxstyle='round', facecolor='wheat', alpha=0.8)
            plt.text(0.02, 0.98, textstr, transform=plt.gca().transAxes, fontsize=10,
                    verticalalignment='top', bbox=props)
            
            # Tight layout and save
            plt.tight_layout()
            
            # Save the plot
            plot_filename = f"{file_prefix}_energy_vs_kpoints.png"
            plt.savefig(plot_filename, dpi=300, bbox_inches='tight')
            print(f"Plot saved as: {plot_filename}")
            
            # Save data in XMGrace format
            grace_filename = f"{file_prefix}_energy_vs_kpoints.agr"
            with open(grace_filename, 'w') as f:
                # Write Grace header
                f.write("# Grace project file\n")
                f.write("# Generated by cif2qe.py\n")
                f.write("@version 50123\n")
                f.write("@page size 792, 612\n")
                f.write("@page scroll 5%\n")
                f.write("@page inout 5%\n")
                f.write("@link page off\n")
                f.write("@map font 0 to \"Times-Roman\", \"Times-Roman\"\n")
                f.write("@map font 1 to \"Times-Italic\", \"Times-Italic\"\n")
                f.write("@map font 2 to \"Times-Bold\", \"Times-Bold\"\n")
                f.write("@map font 3 to \"Times-BoldItalic\", \"Times-BoldItalic\"\n")
                f.write("@map color 0 to (255, 255, 255), \"white\"\n")
                f.write("@map color 1 to (0, 0, 0), \"black\"\n")
                f.write("@map color 2 to (255, 0, 0), \"red\"\n")
                f.write("@map color 3 to (0, 150, 0), \"green\"\n")
                f.write("@map color 4 to (0, 0, 255), \"blue\"\n")
                f.write("@map color 5 to (255, 255, 0), \"yellow\"\n")
                f.write("@reference date 0\n")
                f.write("@date wrap off\n")
                f.write("@date wrap year 1950\n")
                f.write("@default linewidth 1.0\n")
                f.write("@default linestyle 1\n")
                f.write("@default color 1\n")
                f.write("@default pattern 1\n")
                f.write("@default font 0\n")
                f.write("@default char size 1.000000\n")
                f.write("@default symbol size 1.000000\n")
                f.write("@default sformat \"%.8g\"\n")
                f.write("@background color 0\n")
                f.write("@page background fill on\n")
                f.write("@timestamp off\n")
                f.write("@timestamp 0.03, 0.03\n")
                f.write("@timestamp color 1\n")
                f.write("@timestamp rot 0\n")
                f.write("@timestamp font 0\n")
                f.write("@timestamp char size 1.000000\n")
                f.write("@timestamp def \"Date/Time\"\n")
                f.write("@r0 off\n")
                f.write("@link r0 to g0\n")
                f.write("@r0 type above\n")
                f.write("@r0 linestyle 1\n")
                f.write("@r0 linewidth 1.0\n")
                f.write("@r0 color 1\n")
                f.write("@r0 line 0, 0, 0, 0\n")
                f.write("@r1 off\n")
                f.write("@link r1 to g0\n")
                f.write("@r1 type above\n")
                f.write("@r1 linestyle 1\n")
                f.write("@r1 linewidth 1.0\n")
                f.write("@r1 color 1\n")
                f.write("@r1 line 0, 0, 0, 0\n")
                f.write("@g0 on\n")
                f.write("@g0 hidden false\n")
                f.write("@g0 type XY\n")
                f.write("@g0 stacked false\n")
                f.write("@g0 bar hgap 0.000000\n")
                f.write("@g0 fixedpoint off\n")
                f.write("@g0 fixedpoint type 0\n")
                f.write("@g0 fixedpoint xy 0.000000, 0.000000\n")
                f.write("@g0 fixedpoint format general general\n")
                f.write("@g0 fixedpoint prec 6, 6\n")
                f.write("@with g0\n")
                f.write("@    world 0.5, {:.6f}, {:.1f}, {:.6f}\n".format(y_min, len(x_values) + 0.5, y_max))
                f.write("@    stack world 0, 0, 0, 0\n")
                f.write("@    znorm 1\n")
                f.write("@    view 0.150000, 0.150000, 1.150000, 0.850000\n")
                f.write("@    title \"Energy Convergence vs K-points for {}\"\n".format(file_prefix))
                f.write("@    title font 2\n")
                f.write("@    title size 1.500000\n")
                f.write("@    title color 1\n")
                f.write("@    subtitle \"\"\n")
                f.write("@    subtitle font 0\n")
                f.write("@    subtitle size 1.000000\n")
                f.write("@    subtitle color 1\n")
                f.write("@    xaxes scale Normal\n")
                f.write("@    yaxes scale Normal\n")
                f.write("@    xaxes invert off\n")
                f.write("@    yaxes invert off\n")
                f.write("@    xaxis  on\n")
                f.write("@    xaxis  type zero false\n")
                f.write("@    xaxis  offset 0.000000 , 0.000000\n")
                f.write("@    xaxis  bar on\n")
                f.write("@    xaxis  bar color 1\n")
                f.write("@    xaxis  bar linestyle 1\n")
                f.write("@    xaxis  bar linewidth 1.0\n")
                f.write("@    xaxis  label \"Calculation Number\"\n")
                f.write("@    xaxis  label layout para\n")
                f.write("@    xaxis  label place auto\n")
                f.write("@    xaxis  label char size 1.000000\n")
                f.write("@    xaxis  label font 2\n")
                f.write("@    xaxis  label color 1\n")
                f.write("@    xaxis  label place normal\n")
                f.write("@    xaxis  tick on\n")
                f.write("@    xaxis  tick major 1\n")
                f.write("@    xaxis  tick minor ticks 0\n")
                f.write("@    xaxis  tick default 6\n")
                f.write("@    xaxis  tick place rounded true\n")
                f.write("@    xaxis  tick in\n")
                f.write("@    xaxis  tick major size 1.000000\n")
                f.write("@    xaxis  tick major color 1\n")
                f.write("@    xaxis  tick major linewidth 1.0\n")
                f.write("@    xaxis  tick major linestyle 1\n")
                f.write("@    xaxis  tick major grid off\n")
                f.write("@    xaxis  tick minor color 1\n")
                f.write("@    xaxis  tick minor linewidth 1.0\n")
                f.write("@    xaxis  tick minor linestyle 1\n")
                f.write("@    xaxis  tick minor grid off\n")
                f.write("@    xaxis  tick minor size 0.500000\n")
                f.write("@    xaxis  ticklabel on\n")
                f.write("@    xaxis  ticklabel format general\n")
                f.write("@    xaxis  ticklabel prec 0\n")
                f.write("@    xaxis  ticklabel formula \"\"\n")
                f.write("@    xaxis  ticklabel append \"\"\n")
                f.write("@    xaxis  ticklabel prepend \"\"\n")
                f.write("@    xaxis  ticklabel angle 0\n")
                f.write("@    xaxis  ticklabel skip 0\n")
                f.write("@    xaxis  ticklabel stagger 0\n")
                f.write("@    xaxis  ticklabel place normal\n")
                f.write("@    xaxis  ticklabel offset auto\n")
                f.write("@    xaxis  ticklabel offset 0.000000 , 0.010000\n")
                f.write("@    xaxis  ticklabel start type auto\n")
                f.write("@    xaxis  ticklabel start 0.000000\n")
                f.write("@    xaxis  ticklabel stop type auto\n")
                f.write("@    xaxis  ticklabel stop 0.000000\n")
                f.write("@    xaxis  ticklabel char size 1.000000\n")
                f.write("@    xaxis  ticklabel font 0\n")
                f.write("@    xaxis  ticklabel color 1\n")
                f.write("@    xaxis  tick place both\n")
                f.write("@    xaxis  tick spec type none\n")
                f.write("@    yaxis  on\n")
                f.write("@    yaxis  type zero false\n")
                f.write("@    yaxis  offset 0.000000 , 0.000000\n")
                f.write("@    yaxis  bar on\n")
                f.write("@    yaxis  bar color 1\n")
                f.write("@    yaxis  bar linestyle 1\n")
                f.write("@    yaxis  bar linewidth 1.0\n")
                f.write("@    yaxis  label \"Total Energy (Ry)\"\n")
                f.write("@    yaxis  label layout para\n")
                f.write("@    yaxis  label place auto\n")
                f.write("@    yaxis  label char size 1.000000\n")
                f.write("@    yaxis  label font 2\n")
                f.write("@    yaxis  label color 1\n")
                f.write("@    yaxis  label place normal\n")
                f.write("@    yaxis  tick on\n")
                f.write("@    yaxis  tick major {:.6f}\n".format((y_max - y_min) / 10))
                f.write("@    yaxis  tick minor ticks 1\n")
                f.write("@    yaxis  tick default 6\n")
                f.write("@    yaxis  tick place rounded true\n")
                f.write("@    yaxis  tick in\n")
                f.write("@    yaxis  tick major size 1.000000\n")
                f.write("@    yaxis  tick major color 1\n")
                f.write("@    yaxis  tick major linewidth 1.0\n")
                f.write("@    yaxis  tick major linestyle 1\n")
                f.write("@    yaxis  tick major grid on\n")
                f.write("@    yaxis  tick minor color 1\n")
                f.write("@    yaxis  tick minor linewidth 1.0\n")
                f.write("@    yaxis  tick minor linestyle 1\n")
                f.write("@    yaxis  tick minor grid off\n")
                f.write("@    yaxis  tick minor size 0.500000\n")
                f.write("@    yaxis  ticklabel on\n")
                f.write("@    yaxis  ticklabel format general\n")
                f.write("@    yaxis  ticklabel prec 6\n")
                f.write("@    yaxis  ticklabel formula \"\"\n")
                f.write("@    yaxis  ticklabel append \"\"\n")
                f.write("@    yaxis  ticklabel prepend \"\"\n")
                f.write("@    yaxis  ticklabel angle 0\n")
                f.write("@    yaxis  ticklabel skip 0\n")
                f.write("@    yaxis  ticklabel stagger 0\n")
                f.write("@    yaxis  ticklabel place normal\n")
                f.write("@    yaxis  ticklabel offset auto\n")
                f.write("@    yaxis  ticklabel offset 0.000000 , 0.010000\n")
                f.write("@    yaxis  ticklabel start type auto\n")
                f.write("@    yaxis  ticklabel start 0.000000\n")
                f.write("@    yaxis  ticklabel stop type auto\n")
                f.write("@    yaxis  ticklabel stop 0.000000\n")
                f.write("@    yaxis  ticklabel char size 1.000000\n")
                f.write("@    yaxis  ticklabel font 0\n")
                f.write("@    yaxis  ticklabel color 1\n")
                f.write("@    yaxis  tick place both\n")
                f.write("@    yaxis  tick spec type none\n")
                f.write("@    legend on\n")
                f.write("@    legend loctype view\n")
                f.write("@    legend 0.85, 0.8\n")
                f.write("@    legend box color 1\n")
                f.write("@    legend box pattern 1\n")
                f.write("@    legend box linewidth 1.0\n")
                f.write("@    legend box linestyle 1\n")
                f.write("@    legend box fill color 0\n")
                f.write("@    legend box fill pattern 1\n")
                f.write("@    legend font 0\n")
                f.write("@    legend char size 1.000000\n")
                f.write("@    legend color 1\n")
                f.write("@    legend length 4\n")
                f.write("@    legend vgap 1\n")
                f.write("@    legend hgap 1\n")
                f.write("@    legend invert false\n")
                f.write("@    frame type 0\n")
                f.write("@    frame linestyle 1\n")
                f.write("@    frame linewidth 1.0\n")
                f.write("@    frame color 1\n")
                f.write("@    frame pattern 1\n")
                f.write("@    frame background color 0\n")
                f.write("@    frame background pattern 0\n")
                
                # Write dataset 0 (main energy data)
                f.write("@    s0 hidden false\n")
                f.write("@    s0 type xy\n")
                f.write("@    s0 symbol 1\n")  # Circle symbol
                f.write("@    s0 symbol size 1.000000\n")
                f.write("@    s0 symbol color 4\n")  # Blue
                f.write("@    s0 symbol pattern 1\n")
                f.write("@    s0 symbol fill color 4\n")
                f.write("@    s0 symbol fill pattern 1\n")
                f.write("@    s0 symbol linewidth 1.0\n")
                f.write("@    s0 symbol linestyle 1\n")
                f.write("@    s0 symbol char 65\n")
                f.write("@    s0 symbol char font 0\n")
                f.write("@    s0 symbol skip 0\n")
                f.write("@    s0 line type 1\n")  # Solid line
                f.write("@    s0 line linestyle 1\n")
                f.write("@    s0 line linewidth 2.0\n")
                f.write("@    s0 line color 4\n")  # Blue
                f.write("@    s0 line pattern 1\n")
                f.write("@    s0 baseline type 0\n")
                f.write("@    s0 baseline off\n")
                f.write("@    s0 dropline off\n")
                f.write("@    s0 fill type 0\n")
                f.write("@    s0 fill rule 0\n")
                f.write("@    s0 fill color 1\n")
                f.write("@    s0 fill pattern 1\n")
                f.write("@    s0 avalue off\n")
                f.write("@    s0 avalue type 2\n")
                f.write("@    s0 avalue char size 1.000000\n")
                f.write("@    s0 avalue font 0\n")
                f.write("@    s0 avalue color 1\n")
                f.write("@    s0 avalue rot 0\n")
                f.write("@    s0 avalue format general\n")
                f.write("@    s0 avalue prec 3\n")
                f.write("@    s0 avalue prepend \"\"\n")
                f.write("@    s0 avalue append \"\"\n")
                f.write("@    s0 avalue offset 0.000000 , 0.000000\n")
                f.write("@    s0 errorbar on\n")
                f.write("@    s0 errorbar place both\n")
                f.write("@    s0 errorbar color 4\n")
                f.write("@    s0 errorbar pattern 1\n")
                f.write("@    s0 errorbar size 1.000000\n")
                f.write("@    s0 errorbar linewidth 1.0\n")
                f.write("@    s0 errorbar linestyle 1\n")
                f.write("@    s0 errorbar riser linewidth 1.0\n")
                f.write("@    s0 errorbar riser linestyle 1\n")
                f.write("@    s0 errorbar riser clip off\n")
                f.write("@    s0 errorbar riser clip length 0.100000\n")
                f.write("@    s0 comment \"Energy vs K-points\"\n")
                f.write("@    s0 legend  \"Total Energy vs K-points\"\n")
                
                # Write convergence threshold lines if applicable
                if len(energy_data) > 1 and energy_range > convergence_threshold:
                    last_energy = energy_data[-1]
                    
                    # Upper threshold line (dataset 1)
                    f.write("@    s1 hidden false\n")
                    f.write("@    s1 type xy\n")
                    f.write("@    s1 symbol 0\n")  # No symbol
                    f.write("@    s1 line type 3\n")  # Dashed line
                    f.write("@    s1 line linestyle 3\n")
                    f.write("@    s1 line linewidth 1.0\n")
                    f.write("@    s1 line color 2\n")  # Red
                    f.write("@    s1 line pattern 1\n")
                    f.write("@    s1 legend  \"Convergence threshold (+{} Ry)\"\n".format(convergence_threshold))
                    
                    # Lower threshold line (dataset 2)
                    f.write("@    s2 hidden false\n")
                    f.write("@    s2 type xy\n")
                    f.write("@    s2 symbol 0\n")  # No symbol
                    f.write("@    s2 line type 3\n")  # Dashed line
                    f.write("@    s2 line linestyle 3\n")
                    f.write("@    s2 line linewidth 1.0\n")
                    f.write("@    s2 line color 2\n")  # Red
                    f.write("@    s2 line pattern 1\n")
                    f.write("@    s2 legend  \"Convergence threshold (-{} Ry)\"\n".format(convergence_threshold))
                
                # Write data
                f.write("@target G0.S0\n")
                f.write("@type xy\n")
                for x_val, energy in zip(x_values, energy_data):
                    f.write("{:d} {:.8f}\n".format(x_val, energy))
                f.write("&\n")
                
                
                
                #show plot 
                plt.show()
                
                # Ask user for k-points to use for cutoff convergence
                print("\nFor cutoff energy convergence study:")
                while True:
                    kpoint_input = input("Enter k-points to use for the next steps (format: NxNxN, e.g., 11x11x9): ").strip()
                    
                    if not kpoint_input:
                        print("Please enter k-points in the format NxNxN")
                        continue
                    
                    try:
                        # Parse the k-point string
                        kpoint_parts = kpoint_input.split('x')
                        if len(kpoint_parts) != 3:
                            raise ValueError("Must have exactly 3 numbers separated by 'x'")
                        
                        suggested_kp_x = int(kpoint_parts[0])
                        suggested_kp_y = int(kpoint_parts[1])
                        suggested_kp_z = int(kpoint_parts[2])
                        
                        if suggested_kp_x <= 0 or suggested_kp_y <= 0 or suggested_kp_z <= 0:
                            raise ValueError("All k-points must be positive")
                        
                        print(f"Using k-points: {suggested_kp_x}x{suggested_kp_y}x{suggested_kp_z}")
                        break
                        
                    except ValueError as e:
                        print(f"Error: {e}. Please enter in format NxNxN (e.g., 11x11x9)")
                        continue
                
                # Check if the reference input file exists
                reference_input = f"{file_prefix}.{suggested_kp_x}x{suggested_kp_y}x{suggested_kp_z}.scf.in"
                if not os.path.isfile(reference_input):
                    print(f"Error: Reference file {reference_input} not found!")
                    print("Please make sure this k-point combination was generated in the previous step.")
                else:
                    print(f"Found reference file: {reference_input}")
                    
                    # Run cutoff convergence study
                    print("\nRunning cutoff energy convergence study...")
                    print("-" * 60)
                    
                    # Data for plotting cutoff convergence
                    ecutwfc_values = []
                    cutoff_energies = []
                    previous_cutoff_energy = None
                    convergence_count = 0
                    cutoff_convergence_threshold = 0.01
                    required_convergence_steps = 3
                    
                    # Read the reference input file
                    with open(reference_input, 'r') as f:
                        reference_content = f.read()
                    
                    # Generate files for different ecutwfc values
                    for ecutwfc in range(10, 121, 10):  # 10 to 120 with increment of 10
                        ecutrho = ecutwfc * 8
                        
                        # Create new input file with modified ecutwfc and ecutrho
                        modified_content = reference_content
                        
                        # Replace ecutwfc value
                        modified_content = re.sub(r'ecutwfc\s*=\s*[\d.]+', f'ecutwfc = {ecutwfc}', modified_content)
                        modified_content = re.sub(r'ecutrho\s*=\s*[\d.]+', f'ecutrho = {ecutrho}', modified_content)
                        
                        # Create new input and output filenames
                        cutoff_input = f"{file_prefix}.{suggested_kp_x}x{suggested_kp_y}x{suggested_kp_z}.ecut{ecutwfc}.scf.in"
                        cutoff_output = f"{file_prefix}.{suggested_kp_x}x{suggested_kp_y}x{suggested_kp_z}.ecut{ecutwfc}.scf.out"
                        
                        # Write the modified input file
                        with open(cutoff_input, 'w') as f:
                            f.write(modified_content)
                        
                        print(f"\nGenerated {cutoff_input} with ecutwfc={ecutwfc}, ecutrho={ecutrho}")
                        
                        # Run the calculation
                        print(f"Running calculation: {cutoff_input}")
                        success = run_pw_calculation(cutoff_input, cutoff_output, num_cores)
                        
                        if not success:
                            print(f"\n✗ FATAL ERROR: Calculation failed for ecutwfc={ecutwfc}")
                            print("The pw.x calculation did not complete successfully.")
                            print("Please check:")
                            print("- Input file syntax and parameters")
                            print("- Pseudopotential files availability")
                            print("- System resources (memory, disk space)")
                            print("- MPI configuration")
                            print("- ecutwfc and ecutrho values are reasonable")
                            print(f"- Check the output file: {cutoff_output}")
                            sys.exit(1)
                        
                        # Extract total energy
                        total_energy = extract_total_energy(cutoff_output)
                        
                        if total_energy is None:
                            print(f"\n✗ FATAL ERROR: Could not extract total energy for ecutwfc={ecutwfc}")
                            print("The total energy extraction failed.")
                            print("Please check:")
                            print("- The calculation completed successfully")
                            print("- The output file contains energy information")
                            print(f"- Check the output file: {cutoff_output}")
                            print("- The energy pattern in extract_total_energy() function")
                            sys.exit(1)
                        
                        # Store data for plotting
                        ecutwfc_values.append(ecutwfc)
                        cutoff_energies.append(total_energy)
                        
                        print(f"✓ ecutwfc={ecutwfc} Ry, Total Energy: {total_energy:.8f} Ry")
                        
                        # Check convergence
                        if previous_cutoff_energy is not None:
                            energy_diff = abs(total_energy - previous_cutoff_energy)
                            print(f"  Energy difference from previous: {energy_diff:.8f} Ry")
                            
                            if energy_diff < cutoff_convergence_threshold:
                                convergence_count += 1
                                print(f"  Convergence criterion met ({convergence_count}/{required_convergence_steps})")
                                
                                if convergence_count >= required_convergence_steps:
                                    print(f"\n✓ Convergence achieved! Energy difference < {cutoff_convergence_threshold} Ry")
                                    print(f"   for {required_convergence_steps} consecutive ecutwfc values.")
                                    print(f"   Recommended ecutwfc: {ecutwfc} Ry")
                                    break
                            else:
                                convergence_count = 0
                        
                        previous_cutoff_energy = total_energy
                    
                    # Plot cutoff convergence results
                    if len(ecutwfc_values) > 1:
                        print(f"\nPlotting cutoff energy convergence...")
                        
                        # Create the plot
                        plt.figure(figsize=(10, 6))
                        plt.plot(ecutwfc_values, cutoff_energies, 'o-', linewidth=2, markersize=6, color='red', 
                                markerfacecolor='red', markeredgecolor='darkred')
                        plt.xlabel('Cutoff Energy (Ry)', fontsize=12, fontweight='bold')
                        plt.ylabel('Total Energy (Ry)', fontsize=12, fontweight='bold')
                        plt.title(f'Energy Convergence vs Cutoff Energy for {file_prefix}', fontsize=16, fontweight='bold')
                        plt.grid(True, alpha=0.3)
                        plt.tight_layout()
                        
                        # Save plot
                        cutoff_plot_filename = f"{file_prefix}_energy_vs_cutoff.png"
                        plt.savefig(cutoff_plot_filename, dpi=300, bbox_inches='tight')
                        print(f"Plot saved as: {cutoff_plot_filename}")
                        
                        
                        # Save data in XMGrace format for cutoff convergence
                        cutoff_grace_filename = f"{file_prefix}_energy_vs_cutoff.agr"
                        print(f"Saving XMGrace file: {cutoff_grace_filename}")
                        
                        # Calculate y-axis limits for grace file
                        min_cutoff_energy = min(cutoff_energies)
                        max_cutoff_energy = max(cutoff_energies)
                        cutoff_energy_range = max_cutoff_energy - min_cutoff_energy
                        
                        # Ensure minimum range for better visualization
                        min_cutoff_range = 0.05
                        if cutoff_energy_range < min_cutoff_range:
                            center_cutoff_energy = (min_cutoff_energy + max_cutoff_energy) / 2
                            y_min_cutoff = center_cutoff_energy - min_cutoff_range / 2
                            y_max_cutoff = center_cutoff_energy + min_cutoff_range / 2
                        else:
                            padding = cutoff_energy_range * 0.05
                            y_min_cutoff = min_cutoff_energy - padding
                            y_max_cutoff = max_cutoff_energy + padding
                        
                        with open(cutoff_grace_filename, 'w') as f:
                            # Write Grace header
                            f.write("# Grace project file\n")
                            f.write("# Generated by cif2qe.py - Cutoff Energy Convergence\n")
                            f.write("@version 50123\n")
                            f.write("@page size 792, 612\n")
                            f.write("@page scroll 5%\n")
                            f.write("@page inout 5%\n")
                            f.write("@link page off\n")
                            f.write("@map font 0 to \"Times-Roman\", \"Times-Roman\"\n")
                            f.write("@map font 1 to \"Times-Italic\", \"Times-Italic\"\n")
                            f.write("@map font 2 to \"Times-Bold\", \"Times-Bold\"\n")
                            f.write("@map font 3 to \"Times-BoldItalic\", \"Times-BoldItalic\"\n")
                            f.write("@map color 0 to (255, 255, 255), \"white\"\n")
                            f.write("@map color 1 to (0, 0, 0), \"black\"\n")
                            f.write("@map color 2 to (255, 0, 0), \"red\"\n")
                            f.write("@map color 3 to (0, 150, 0), \"green\"\n")
                            f.write("@map color 4 to (0, 0, 255), \"blue\"\n")
                            f.write("@map color 5 to (255, 255, 0), \"yellow\"\n")
                            f.write("@reference date 0\n")
                            f.write("@date wrap off\n")
                            f.write("@date wrap year 1950\n")
                            f.write("@default linewidth 1.0\n")
                            f.write("@default linestyle 1\n")
                            f.write("@default color 1\n")
                            f.write("@default pattern 1\n")
                            f.write("@default font 0\n")
                            f.write("@default char size 1.000000\n")
                            f.write("@default symbol size 1.000000\n")
                            f.write("@default sformat \"%.8g\"\n")
                            f.write("@background color 0\n")
                            f.write("@page background fill on\n")
                            f.write("@timestamp off\n")
                            f.write("@g0 on\n")
                            f.write("@g0 hidden false\n")
                            f.write("@g0 type XY\n")
                            f.write("@g0 stacked false\n")
                            f.write("@with g0\n")
                            f.write("@    world 5, {:.6f}, {}, {:.6f}\n".format(y_min_cutoff, max(ecutwfc_values) + 10, y_max_cutoff))
                            f.write("@    stack world 0, 0, 0, 0\n")
                            f.write("@    znorm 1\n")
                            f.write("@    view 0.150000, 0.150000, 1.150000, 0.850000\n")
                            f.write("@    title \"Energy Convergence vs Cutoff Energy for {}\"\n".format(file_prefix))
                            f.write("@    title font 2\n")
                            f.write("@    title size 1.500000\n")
                            f.write("@    title color 1\n")
                            f.write("@    subtitle \"\"\n")
                            f.write("@    xaxes scale Normal\n")
                            f.write("@    yaxes scale Normal\n")
                            f.write("@    xaxes invert off\n")
                            f.write("@    yaxes invert off\n")
                            f.write("@    xaxis  on\n")
                            f.write("@    xaxis  type zero false\n")
                            f.write("@    xaxis  offset 0.000000 , 0.000000\n")
                            f.write("@    xaxis  bar on\n")
                            f.write("@    xaxis  bar color 1\n")
                            f.write("@    xaxis  bar linestyle 1\n")
                            f.write("@    xaxis  bar linewidth 1.0\n")
                            f.write("@    xaxis  label \"Cutoff Energy (Ry)\"\n")
                            f.write("@    xaxis  label layout para\n")
                            f.write("@    xaxis  label place auto\n")
                            f.write("@    xaxis  label char size 1.000000\n")
                            f.write("@    xaxis  label font 2\n")
                            f.write("@    xaxis  label color 1\n")
                            f.write("@    xaxis  label place normal\n")
                            f.write("@    xaxis  tick on\n")
                            f.write("@    xaxis  tick major 10\n")
                            f.write("@    xaxis  tick minor ticks 1\n")
                            f.write("@    xaxis  tick default 6\n")
                            f.write("@    xaxis  tick place rounded true\n")
                            f.write("@    xaxis  tick in\n")
                            f.write("@    xaxis  tick major size 1.000000\n")
                            f.write("@    xaxis  tick major color 1\n")
                            f.write("@    xaxis  tick major linewidth 1.0\n")
                            f.write("@    xaxis  tick major linestyle 1\n")
                            f.write("@    xaxis  tick major grid on\n")
                            f.write("@    xaxis  tick minor color 1\n")
                            f.write("@    xaxis  tick minor linewidth 1.0\n")
                            f.write("@    xaxis  tick minor linestyle 1\n")
                            f.write("@    xaxis  tick minor grid off\n")
                            f.write("@    xaxis  tick minor size 0.500000\n")
                            f.write("@    xaxis  ticklabel on\n")
                            f.write("@    xaxis  ticklabel format decimal\n")
                            f.write("@    xaxis  ticklabel prec 0\n")
                            f.write("@    yaxis  on\n")
                            f.write("@    yaxis  type zero false\n")
                            f.write("@    yaxis  offset 0.000000 , 0.000000\n")
                            f.write("@    yaxis  bar on\n")
                            f.write("@    yaxis  bar color 1\n")
                            f.write("@    yaxis  bar linestyle 1\n")
                            f.write("@    yaxis  bar linewidth 1.0\n")
                            f.write("@    yaxis  label \"Total Energy (Ry)\"\n")
                            f.write("@    yaxis  label layout para\n")
                            f.write("@    yaxis  label place auto\n")
                            f.write("@    yaxis  label char size 1.000000\n")
                            f.write("@    yaxis  label font 2\n")
                            f.write("@    yaxis  label color 1\n")
                            f.write("@    yaxis  label place normal\n")
                            f.write("@    yaxis  tick on\n")
                            f.write("@    yaxis  tick major {:.6f}\n".format((y_max_cutoff - y_min_cutoff) / 10))
                            f.write("@    yaxis  tick minor ticks 1\n")
                            f.write("@    yaxis  tick default 6\n")
                            f.write("@    yaxis  tick place rounded true\n")
                            f.write("@    yaxis  tick in\n")
                            f.write("@    yaxis  tick major size 1.000000\n")
                            f.write("@    yaxis  tick major color 1\n")
                            f.write("@    yaxis  tick major linewidth 1.0\n")
                            f.write("@    yaxis  tick major linestyle 1\n")
                            f.write("@    yaxis  tick major grid on\n")
                            f.write("@    yaxis  tick minor color 1\n")
                            f.write("@    yaxis  tick minor linewidth 1.0\n")
                            f.write("@    yaxis  tick minor linestyle 1\n")
                            f.write("@    yaxis  tick minor grid off\n")
                            f.write("@    yaxis  tick minor size 0.500000\n")
                            f.write("@    yaxis  ticklabel on\n")
                            f.write("@    yaxis  ticklabel format general\n")
                            f.write("@    yaxis  ticklabel prec 6\n")
                            f.write("@    legend on\n")
                            f.write("@    legend loctype view\n")
                            f.write("@    legend 0.85, 0.8\n")
                            f.write("@    legend box color 1\n")
                            f.write("@    legend box pattern 1\n")
                            f.write("@    legend box linewidth 1.0\n")
                            f.write("@    legend box linestyle 1\n")
                            f.write("@    legend box fill color 0\n")
                            f.write("@    legend box fill pattern 1\n")
                            f.write("@    legend font 0\n")
                            f.write("@    legend char size 1.000000\n")
                            f.write("@    legend color 1\n")
                            f.write("@    frame type 0\n")
                            f.write("@    frame linestyle 1\n")
                            f.write("@    frame linewidth 1.0\n")
                            f.write("@    frame color 1\n")
                            f.write("@    frame pattern 1\n")
                            f.write("@    frame background color 0\n")
                            f.write("@    frame background pattern 0\n")
                            
                            # Write dataset 0 (main cutoff energy data)
                            f.write("@    s0 hidden false\n")
                            f.write("@    s0 type xy\n")
                            f.write("@    s0 symbol 1\n")  # Circle symbol
                            f.write("@    s0 symbol size 1.000000\n")
                            f.write("@    s0 symbol color 2\n")  # Red
                            f.write("@    s0 symbol pattern 1\n")
                            f.write("@    s0 symbol fill color 2\n")
                            f.write("@    s0 symbol fill pattern 1\n")
                            f.write("@    s0 symbol linewidth 1.0\n")
                            f.write("@    s0 symbol linestyle 1\n")
                            f.write("@    s0 line type 1\n")  # Solid line
                            f.write("@    s0 line linestyle 1\n")
                            f.write("@    s0 line linewidth 2.0\n")
                            f.write("@    s0 line color 2\n")  # Red
                            f.write("@    s0 line pattern 1\n")
                            f.write("@    s0 baseline type 0\n")
                            f.write("@    s0 baseline off\n")
                            f.write("@    s0 dropline off\n")
                            f.write("@    s0 fill type 0\n")
                            f.write("@    s0 fill rule 0\n")
                            f.write("@    s0 fill color 1\n")
                            f.write("@    s0 fill pattern 1\n")
                            f.write("@    s0 comment \"Energy vs Cutoff Energy\"\n")
                            f.write("@    s0 legend  \"Total Energy vs Cutoff Energy\"\n")
                            
                            # Add convergence threshold lines if applicable
                            if len(cutoff_energies) > 1 and cutoff_energy_range > cutoff_convergence_threshold:
                                last_cutoff_energy = cutoff_energies[-1]
                                
                                # Upper threshold line (dataset 1)
                                f.write("@    s1 hidden false\n")
                                f.write("@    s1 type xy\n")
                                f.write("@    s1 symbol 0\n")  # No symbol
                                f.write("@    s1 line type 3\n")  # Dashed line
                                f.write("@    s1 line linestyle 3\n")
                                f.write("@    s1 line linewidth 1.0\n")
                                f.write("@    s1 line color 4\n")  # Blue
                                f.write("@    s1 line pattern 1\n")
                                f.write("@    s1 legend  \"Convergence threshold (+{} Ry)\"\n".format(cutoff_convergence_threshold))
                                
                                # Lower threshold line (dataset 2)
                                f.write("@    s2 hidden false\n")
                                f.write("@    s2 type xy\n")
                                f.write("@    s2 symbol 0\n")  # No symbol
                                f.write("@    s2 line type 3\n")  # Dashed line
                                f.write("@    s2 line linestyle 3\n")
                                f.write("@    s2 line linewidth 1.0\n")
                                f.write("@    s2 line color 4\n")  # Blue
                                f.write("@    s2 line pattern 1\n")
                                f.write("@    s2 legend  \"Convergence threshold (-{} Ry)\"\n".format(cutoff_convergence_threshold))
                            
                            # Write main data
                            f.write("@target G0.S0\n")
                            f.write("@type xy\n")
                            for ecutwfc, energy in zip(ecutwfc_values, cutoff_energies):
                                f.write("{:d} {:.8f}\n".format(ecutwfc, energy))
                            f.write("&\n")
                            
                            # Write convergence threshold lines data if applicable
                            if len(cutoff_energies) > 1 and cutoff_energy_range > cutoff_convergence_threshold:
                                last_cutoff_energy = cutoff_energies[-1]
                                min_ecutwfc = min(ecutwfc_values)
                                max_ecutwfc = max(ecutwfc_values)
                                
                                # Upper threshold line
                                f.write("@target G0.S1\n")
                                f.write("@type xy\n")
                                f.write("{:d} {:.8f}\n".format(min_ecutwfc, last_cutoff_energy + cutoff_convergence_threshold))
                                f.write("{:d} {:.8f}\n".format(max_ecutwfc, last_cutoff_energy + cutoff_convergence_threshold))
                                f.write("&\n")
                                
                                # Lower threshold line
                                f.write("@target G0.S2\n")
                                f.write("@type xy\n")
                                f.write("{:d} {:.8f}\n".format(min_ecutwfc, last_cutoff_energy - cutoff_convergence_threshold))
                                f.write("{:d} {:.8f}\n".format(max_ecutwfc, last_cutoff_energy - cutoff_convergence_threshold))
                                f.write("&\n")
                        
                        print(f"XMGrace file saved as: {cutoff_grace_filename}")
                        
                        # Show plot
                        plt.show()
                        
                        # Ask user for ecutwfc value to use for degauss convergence
                        print("\nFor degauss convergence study:")
                        while True:
                            ecutwfc_input = input("Enter ecutwfc value to use for the next steps (e.g., 50): ").strip()
                            
                            if not ecutwfc_input:
                                print("Please enter a positive integer for ecutwfc value")
                                continue
                            
                            try:
                                suggested_ecutwfc = int(ecutwfc_input)
                                
                                if suggested_ecutwfc <= 0:
                                    raise ValueError("ecutwfc must be positive")
                                
                                print(f"Using ecutwfc: {suggested_ecutwfc}")
                                break
                                
                            except ValueError as e:
                                print(f"Error: Please enter a positive integer (e.g., 50)")
                                continue
                        
                        # Check if the reference input file exists
                        reference_degauss_input = f"{file_prefix}.{suggested_kp_x}x{suggested_kp_y}x{suggested_kp_z}.ecut{suggested_ecutwfc}.scf.in"
                        if not os.path.isfile(reference_degauss_input):
                            print(f"Error: Reference file {reference_degauss_input} not found!")
                            print("Please make sure this ecutwfc value was used in the previous cutoff convergence step.")
                        else:
                            print(f"Found reference file: {reference_degauss_input}")
                            
                            # Run degauss convergence study
                            print("\nRunning degauss convergence study...")
                            print("-" * 60)
                            
                            # Data for plotting degauss convergence
                            degauss_values = []
                            degauss_energies = []
                            previous_degauss_energy = None
                            degauss_convergence_threshold = 0.001
                            
                            # Read the reference input file
                            with open(reference_degauss_input, 'r') as f:
                                reference_degauss_content = f.read()
                            
                            # Generate files for different degauss values
                            degauss = 0.01
                            while degauss <= 0.05:
                                # Create new input file with modified degauss
                                modified_degauss_content = reference_degauss_content
                                
                                # Replace degauss value (or add it if not present)
                                if 'degauss' in modified_degauss_content:
                                    modified_degauss_content = re.sub(r'degauss\s*=\s*[\d.]+', f'degauss = {degauss:.3f}', modified_degauss_content)
                                else:
                                    # Add degauss parameter in the &system namelist
                                    modified_degauss_content = re.sub(r'(&system[^/]*)', f'\\1    degauss = {degauss:.3f}\n', modified_degauss_content, flags=re.DOTALL)
                                
                                # Create new input and output filenames
                                degauss_input = f"{file_prefix}.{suggested_kp_x}x{suggested_kp_y}x{suggested_kp_z}.ecut{suggested_ecutwfc}.degauss{degauss:.3f}.scf.in"
                                degauss_output = f"{file_prefix}.{suggested_kp_x}x{suggested_kp_y}x{suggested_kp_z}.ecut{suggested_ecutwfc}.degauss{degauss:.3f}.scf.out"
                                
                                # Write the modified input file
                                with open(degauss_input, 'w') as f:
                                    f.write(modified_degauss_content)
                                
                                print(f"\nGenerated {degauss_input} with degauss={degauss:.3f}")
                                
                                # Run the calculation
                                print(f"Running calculation: {degauss_input}")
                                success = run_pw_calculation(degauss_input, degauss_output, num_cores)
                                
                                if not success:
                                    print(f"\n✗ FATAL ERROR: Calculation failed for degauss={degauss:.3f}")
                                    print("The pw.x calculation did not complete successfully.")
                                    print("Please check:")
                                    print("- Input file syntax and parameters")
                                    print("- Pseudopotential files availability")
                                    print("- System resources (memory, disk space)")
                                    print("- MPI configuration")
                                    print("- degauss value is reasonable")
                                    print(f"- Check the output file: {degauss_output}")
                                    sys.exit(1)
                                
                                # Extract total energy
                                total_energy = extract_total_energy(degauss_output)
                                
                                if total_energy is None:
                                    print(f"\n✗ FATAL ERROR: Could not extract total energy for degauss={degauss:.3f}")
                                    print("The total energy extraction failed.")
                                    print("Please check:")
                                    print("- The calculation completed successfully")
                                    print("- The output file contains energy information")
                                    print(f"- Check the output file: {degauss_output}")
                                    print("- The energy pattern in extract_total_energy() function")
                                    sys.exit(1)
                                
                                # Store data for plotting
                                degauss_values.append(degauss)
                                degauss_energies.append(total_energy)
                                
                                print(f"✓ degauss={degauss:.3f}, Total Energy: {total_energy:.8f} Ry")
                                
                                # Check convergence
                                if previous_degauss_energy is not None:
                                    energy_diff = abs(total_energy - previous_degauss_energy)
                                    print(f"  Energy difference from previous: {energy_diff:.8f} Ry")
                                    
                                    if energy_diff > degauss_convergence_threshold:
                                        print(f"  Energy difference > {degauss_convergence_threshold} Ry, stopping degauss convergence study")
                                        break
                                
                                previous_degauss_energy = total_energy
                                degauss += 0.005
                            
                            # Plot degauss convergence results
                            if len(degauss_values) > 1:
                                print(f"\nPlotting degauss convergence...")
                                
                                # Create the plot
                                plt.figure(figsize=(10, 6))
                                plt.plot(degauss_values, degauss_energies, 'o-', linewidth=2, markersize=6, color='green', 
                                        markerfacecolor='green', markeredgecolor='darkgreen')
                                plt.xlabel('Degauss (Ry)', fontsize=12, fontweight='bold')
                                plt.ylabel('Total Energy (Ry)', fontsize=12, fontweight='bold')
                                plt.title(f'Energy Convergence vs Degauss for {file_prefix}', fontsize=16, fontweight='bold')
                                plt.grid(True, alpha=0.3)
                                
                                # Set minimum y-axis range to 0.05 Ry
                                min_degauss_energy = min(degauss_energies)
                                max_degauss_energy = max(degauss_energies)
                                degauss_energy_range = max_degauss_energy - min_degauss_energy
                                
                                # Ensure minimum range of 0.05 Ry
                                min_degauss_range = 0.05
                                if degauss_energy_range < min_degauss_range:
                                    center_degauss_energy = (min_degauss_energy + max_degauss_energy) / 2
                                    y_min_degauss = center_degauss_energy - min_degauss_range / 2
                                    y_max_degauss = center_degauss_energy + min_degauss_range / 2
                                else:
                                    padding = degauss_energy_range * 0.05
                                    y_min_degauss = min_degauss_energy - padding
                                    y_max_degauss = max_degauss_energy + padding
                                
                                plt.ylim(y_min_degauss, y_max_degauss)
                                plt.tight_layout()
                                
                                # Save plot
                                degauss_plot_filename = f"{file_prefix}_energy_vs_degauss.png"
                                plt.savefig(degauss_plot_filename, dpi=300, bbox_inches='tight')
                                print(f"Plot saved as: {degauss_plot_filename}")
                                
                                # Save data in XMGrace format for degauss convergence
                                degauss_grace_filename = f"{file_prefix}_energy_vs_degauss.agr"
                                print(f"Saving XMGrace file: {degauss_grace_filename}")
                                
                                with open(degauss_grace_filename, 'w') as f:
                                    # Write Grace header
                                    f.write("# Grace project file\n")
                                    f.write("# Generated by cif2qe.py - Degauss Convergence\n")
                                    f.write("@version 50123\n")
                                    f.write("@page size 792, 612\n")
                                    f.write("@page scroll 5%\n")
                                    f.write("@page inout 5%\n")
                                    f.write("@link page off\n")
                                    f.write("@map font 0 to \"Times-Roman\", \"Times-Roman\"\n")
                                    f.write("@map font 1 to \"Times-Italic\", \"Times-Italic\"\n")
                                    f.write("@map font 2 to \"Times-Bold\", \"Times-Bold\"\n")
                                    f.write("@map font 3 to \"Times-BoldItalic\", \"Times-BoldItalic\"\n")
                                    f.write("@map color 0 to (255, 255, 255), \"white\"\n")
                                    f.write("@map color 1 to (0, 0, 0), \"black\"\n")
                                    f.write("@map color 2 to (255, 0, 0), \"red\"\n")
                                    f.write("@map color 3 to (0, 150, 0), \"green\"\n")
                                    f.write("@map color 4 to (0, 0, 255), \"blue\"\n")
                                    f.write("@map color 5 to (255, 255, 0), \"yellow\"\n")
                                    f.write("@reference date 0\n")
                                    f.write("@date wrap off\n")
                                    f.write("@date wrap year 1950\n")
                                    f.write("@default linewidth 1.0\n")
                                    f.write("@default linestyle 1\n")
                                    f.write("@default color 1\n")
                                    f.write("@default pattern 1\n")
                                    f.write("@default font 0\n")
                                    f.write("@default char size 1.000000\n")
                                    f.write("@default symbol size 1.000000\n")
                                    f.write("@default sformat \"%.8g\"\n")
                                    f.write("@background color 0\n")
                                    f.write("@page background fill on\n")
                                    f.write("@timestamp off\n")
                                    f.write("@g0 on\n")
                                    f.write("@g0 hidden false\n")
                                    f.write("@g0 type XY\n")
                                    f.write("@g0 stacked false\n")
                                    f.write("@with g0\n")
                                    f.write("@    world {:.3f}, {:.6f}, {:.3f}, {:.6f}\n".format(min(degauss_values) - 0.005, y_min_degauss, max(degauss_values) + 0.005, y_max_degauss))
                                    f.write("@    stack world 0, 0, 0, 0\n")
                                    f.write("@    znorm 1\n")
                                    f.write("@    view 0.150000, 0.150000, 1.150000, 0.850000\n")
                                    f.write("@    title \"Energy Convergence vs Degauss for {}\"\n".format(file_prefix))
                                    f.write("@    title font 2\n")
                                    f.write("@    title size 1.500000\n")
                                    f.write("@    title color 1\n")
                                    f.write("@    subtitle \"\"\n")
                                    f.write("@    xaxes scale Normal\n")
                                    f.write("@    yaxes scale Normal\n")
                                    f.write("@    xaxes invert off\n")
                                    f.write("@    yaxes invert off\n")
                                    f.write("@    xaxis  on\n")
                                    f.write("@    xaxis  type zero false\n")
                                    f.write("@    xaxis  offset 0.000000 , 0.000000\n")
                                    f.write("@    xaxis  bar on\n")
                                    f.write("@    xaxis  bar color 1\n")
                                    f.write("@    xaxis  bar linestyle 1\n")
                                    f.write("@    xaxis  bar linewidth 1.0\n")
                                    f.write("@    xaxis  label \"Degauss (Ry)\"\n")
                                    f.write("@    xaxis  label layout para\n")
                                    f.write("@    xaxis  label place auto\n")
                                    f.write("@    xaxis  label char size 1.000000\n")
                                    f.write("@    xaxis  label font 2\n")
                                    f.write("@    xaxis  label color 1\n")
                                    f.write("@    xaxis  label place normal\n")
                                    f.write("@    xaxis  tick on\n")
                                    f.write("@    xaxis  tick major 0.005\n")
                                    f.write("@    xaxis  tick minor ticks 1\n")
                                    f.write("@    xaxis  tick default 6\n")
                                    f.write("@    xaxis  tick place rounded true\n")
                                    f.write("@    xaxis  tick in\n")
                                    f.write("@    xaxis  tick major size 1.000000\n")
                                    f.write("@    xaxis  tick major color 1\n")
                                    f.write("@    xaxis  tick major linewidth 1.0\n")
                                    f.write("@    xaxis  tick major linestyle 1\n")
                                    f.write("@    xaxis  tick major grid on\n")
                                    f.write("@    xaxis  tick minor color 1\n")
                                    f.write("@    xaxis  tick minor linewidth 1.0\n")
                                    f.write("@    xaxis  tick minor linestyle 1\n")
                                    f.write("@    xaxis  tick minor grid off\n")
                                    f.write("@    xaxis  tick minor size 0.500000\n")
                                    f.write("@    xaxis  ticklabel on\n")
                                    f.write("@    xaxis  ticklabel format decimal\n")
                                    f.write("@    xaxis  ticklabel prec 3\n")
                                    f.write("@    yaxis  on\n")
                                    f.write("@    yaxis  type zero false\n")
                                    f.write("@    yaxis  offset 0.000000 , 0.000000\n")
                                    f.write("@    yaxis  bar on\n")
                                    f.write("@    yaxis  bar color 1\n")
                                    f.write("@    yaxis  bar linestyle 1\n")
                                    f.write("@    yaxis  bar linewidth 1.0\n")
                                    f.write("@    yaxis  label \"Total Energy (Ry)\"\n")
                                    f.write("@    yaxis  label layout para\n")
                                    f.write("@    yaxis  label place auto\n")
                                    f.write("@    yaxis  label char size 1.000000\n")
                                    f.write("@    yaxis  label font 2\n")
                                    f.write("@    yaxis  label color 1\n")
                                    f.write("@    yaxis  label place normal\n")
                                    f.write("@    yaxis  tick on\n")
                                    f.write("@    yaxis  tick major {:.6f}\n".format((y_max_degauss - y_min_degauss) / 10))
                                    f.write("@    yaxis  tick minor ticks 1\n")
                                    f.write("@    yaxis  tick default 6\n")
                                    f.write("@    yaxis  tick place rounded true\n")
                                    f.write("@    yaxis  tick in\n")
                                    f.write("@    yaxis  tick major size 1.000000\n")
                                    f.write("@    yaxis  tick major color 1\n")
                                    f.write("@    yaxis  tick major linewidth 1.0\n")
                                    f.write("@    yaxis  tick major linestyle 1\n")
                                    f.write("@    yaxis  tick major grid on\n")
                                    f.write("@    yaxis  tick minor color 1\n")
                                    f.write("@    yaxis  tick minor linewidth 1.0\n")
                                    f.write("@    yaxis  tick minor linestyle 1\n")
                                    f.write("@    yaxis  tick minor grid off\n")
                                    f.write("@    yaxis  tick minor size 0.500000\n")
                                    f.write("@    yaxis  ticklabel on\n")
                                    f.write("@    yaxis  ticklabel format general\n")
                                    f.write("@    yaxis  ticklabel prec 6\n")
                                    f.write("@    legend on\n")
                                    f.write("@    legend loctype view\n")
                                    f.write("@    legend 0.85, 0.8\n")
                                    f.write("@    legend box color 1\n")
                                    f.write("@    legend box pattern 1\n")
                                    f.write("@    legend box linewidth 1.0\n")
                                    f.write("@    legend box linestyle 1\n")
                                    f.write("@    legend box fill color 0\n")
                                    f.write("@    legend box fill pattern 1\n")
                                    f.write("@    legend font 0\n")
                                    f.write("@    legend char size 1.000000\n")
                                    f.write("@    legend color 1\n")
                                    f.write("@    frame type 0\n")
                                    f.write("@    frame linestyle 1\n")
                                    f.write("@    frame linewidth 1.0\n")
                                    f.write("@    frame color 1\n")
                                    f.write("@    frame pattern 1\n")
                                    f.write("@    frame background color 0\n")
                                    f.write("@    frame background pattern 0\n")
                                    
                                    # Write dataset 0 (main degauss energy data)
                                    f.write("@    s0 hidden false\n")
                                    f.write("@    s0 type xy\n")
                                    f.write("@    s0 symbol 1\n")  # Circle symbol
                                    f.write("@    s0 symbol size 1.000000\n")
                                    f.write("@    s0 symbol color 3\n")  # Green
                                    f.write("@    s0 symbol pattern 1\n")
                                    f.write("@    s0 symbol fill color 3\n")
                                    f.write("@    s0 symbol fill pattern 1\n")
                                    f.write("@    s0 symbol linewidth 1.0\n")
                                    f.write("@    s0 symbol linestyle 1\n")
                                    f.write("@    s0 line type 1\n")  # Solid line
                                    f.write("@    s0 line linestyle 1\n")
                                    f.write("@    s0 line linewidth 2.0\n")
                                    f.write("@    s0 line color 3\n")  # Green
                                    f.write("@    s0 line pattern 1\n")
                                    f.write("@    s0 baseline type 0\n")
                                    f.write("@    s0 baseline off\n")
                                    f.write("@    s0 dropline off\n")
                                    f.write("@    s0 fill type 0\n")
                                    f.write("@    s0 fill rule 0\n")
                                    f.write("@    s0 fill color 1\n")
                                    f.write("@    s0 fill pattern 1\n")
                                    f.write("@    s0 comment \"Energy vs Degauss\"\n")
                                    f.write("@    s0 legend  \"Total Energy vs Degauss\"\n")
                                    
                                    # Write main data
                                    f.write("@target G0.S0\n")
                                    f.write("@type xy\n")
                                    for degauss, energy in zip(degauss_values, degauss_energies):
                                        f.write("{:.3f} {:.8f}\n".format(degauss, energy))
                                    f.write("&\n")
                                
                                print(f"XMGrace file saved as: {degauss_grace_filename}")
                                
                                # Show plot
                                plt.show()
                                
                                # Print degauss convergence table
                                print(f"\nDegauss Convergence Results:")
                                print("-" * 60)
                                print(f"{'degauss (Ry)':<12} {'Total Energy (Ry)':<18} {'ΔE (Ry)':<12}")
                                print("-" * 60)
                                for i, (degauss, energy) in enumerate(zip(degauss_values, degauss_energies)):
                                    if i == 0:
                                        delta_e = "N/A"
                                    else:
                                        delta_e = f"{abs(energy - degauss_energies[i-1]):.8f}"
                                    print(f"{degauss:<12.3f} {energy:<18.8f} {delta_e:<12}")
                                print("-" * 60)
                        
                        # Print cutoff convergence table
                        print(f"\nCutoff Energy Convergence Results:")
                        print("-" * 70)
                        print(f"{'ecutwfc (Ry)':<12} {'ecutrho (Ry)':<12} {'Total Energy (Ry)':<18} {'ΔE (Ry)':<12}")
                        print("-" * 70)
                        for i, (ecutwfc, energy) in enumerate(zip(ecutwfc_values, cutoff_energies)):
                            ecutrho = ecutwfc * 8
                            if i == 0:
                                delta_e = "N/A"
                            else:
                                delta_e = f"{abs(energy - cutoff_energies[i-1]):.8f}"
                            print(f"{ecutwfc:<12} {ecutrho:<12} {energy:<18.8f} {delta_e:<12}")
                        print("-" * 70)
                

        
            
            # Print data table
            print(f"\nEnergy vs K-points data:")
            print("-" * 70)
            print(f"{'Calc #':<8} {'K-points':<15} {'Total K':<10} {'Energy (Ry)':<15} {'ΔE (Ry)':<12}")
            print("-" * 70)
            for i, (k_total, energy, k_label) in enumerate(zip(k_points_data, energy_data, k_point_labels)):
                if i == 0:
                    delta_e = "N/A"
                else:
                    delta_e = f"{abs(energy - energy_data[i-1]):.6f}"
                print(f"{i+1:<8} {k_label:<15} {k_total:<10} {energy:<15.8f} {delta_e:<12}")
            print("-" * 70)
        
        # Ask user for degauss value to use for next steps
        print("\nFor next steps:")
        while True:
            degauss_input = input("Enter degauss value to use for next steps (e.g., 0.02): ").strip()
            
            if not degauss_input:
                print("Please enter a degauss value")
                continue
            
            try:
                suggested_degauss = float(degauss_input)
                
                if suggested_degauss <= 0:
                    raise ValueError("degauss must be positive")
                
                print(f"Using degauss: {suggested_degauss}  for next steps")
                suggested_degauss = f"{suggested_degauss:.3f}"
                break
                
            except ValueError as e:
                print(f"Error: Please enter a positive number (e.g., 0.02)")
                continue
        
        # Change back to the original working directory
        os.chdir(original_cwd)   
        return suggested_kp_x, suggested_kp_y, suggested_kp_z, suggested_ecutwfc, suggested_degauss
        
    except Exception as e:
        print(f"Error processing file: {e}")
        sys.exit(1)

# Generating tuned_scf.in file
def generate_tuned_scf_input(suggested_kp_x, suggested_kp_y, suggested_kp_z, suggested_ecutwfc, suggested_degauss, celldm_block, atomic_positions_block):
    # Check if the reference input file exists
    output_dir = "SOC.convergence"
    ref_input = f"{file_prefix}.{suggested_kp_x}x{suggested_kp_y}x{suggested_kp_z}.ecut{suggested_ecutwfc}.degauss{suggested_degauss}.scf.in"
    # ref_input = os.path.join(output_dir, ref_input)
    if not os.path.isfile(ref_input):
        print(f"Error: Reference file {ref_input} not found!")
        print("Please make sure this k-point combination was generated in the previous step.")
    else:
        print(f"Found reference file: {ref_input}")
    pass

    #Read the reference input file
    with open(ref_input, 'r') as f:
        ref_content = f.read()
        
    modi_content = ref_content
    
    # Extract celldm values from celldm_block
    celldm_values = {}
    celldm_pattern = re.compile(r'celldm\((\d+)\)\s*=\s*([0-9Ee\.\-+, ]+)')
    for match in celldm_pattern.finditer(celldm_block):
        idx = match.group(1)
        val = match.group(2).split(',')[0].strip()  # Remove trailing comma if present
        celldm_values[idx] = val
        
    # Extract celldm values from celldm_block
    celldm_values = {}
    celldm_pattern = re.compile(r'celldm\((\d+)\)\s*=\s*([0-9Ee\.\-+, ]+)')
    for match in celldm_pattern.finditer(celldm_block):
        idx = match.group(1)
        val = match.group(2).split(',')[0].strip()  # Remove trailing comma if present
        celldm_values[idx] = val
        modi_content = re.sub(rf'celldm\({idx}\)\s*=\s*[0-9Ee\.\-+, ]+', f'celldm({idx}) = {val}', modi_content)


    # Replace lines between 'ATOMIC_POSITIONS' and 'K_POINTS' with atomic_positions_block
    # Replace only the lines between 'ATOMIC_POSITIONS' and 'K_POINTS', keeping both headers
    modi_content = re.sub(
        r'(ATOMIC_POSITIONS[^\n]*\n)(.*?)(\nK_POINTS)',
        r'\1' + atomic_positions_block + r'\3',
        modi_content,
        flags=re.DOTALL
    )

    tuned_scf_input = f"{file_prefix}.SOC.tuned_scf.in"
    # write the modified input file
    with open(tuned_scf_input, 'w') as f:
        f.write(modi_content)

def vc_relax_run(suggested_kp_x, suggested_kp_y, suggested_kp_z, suggested_ecutwfc, suggested_degauss):
    # Check if the reference input file exists
    ref_input = f"{file_prefix}.{suggested_kp_x}x{suggested_kp_y}x{suggested_kp_z}.ecut{suggested_ecutwfc}.degauss{suggested_degauss}.scf.in"
    if not os.path.isfile(ref_input):
        print(f"Error: Reference file {ref_input} not found!")
        print("Please make sure this k-point combination was generated in the previous step.")
    else:
        print(f"Found reference file: {ref_input}")
    pass

    #Read the reference input file
    with open(ref_input, 'r') as f:
        ref_content = f.read()
        
    mod_content = ref_content
    # Create new input file with modified ecutwfc and ecutrho
    mod_content = re.sub(r"outdir\s*=\s*['\"].*?['\"]", f'outdir = "{file_prefix}.vc_relax.outdir"', mod_content)
    mod_content = re.sub(r"calculation\s*=\s*['\"].*?['\"]", "calculation = 'vc-relax'", mod_content)
    # Replace the K_POINTS automatic line (e.g., '11  11  9   0 0 0') with '20  20  20   0 0 0'
    mod_content = re.sub(r'^\s*\d+\s+\d+\s+\d+\s+0\s+0\s+0\s*$','24  24  24   0 0 0',mod_content,flags=re.MULTILINE)

    # Insert &IONS and &CELL blocks before ATOMIC_SPECIES
    ions_cell_block = (
        "&IONS\n"
        "   ion_dynamics='bfgs',\n"
        "/\n"
        "&CELL\n"
        "   cell_dofree='ibrav',\n"
        "   cell_dynamics='bfgs',\n"
        "   press=0.0,\n"
        "   press_conv_thr=0.0,\n"
        "/\n"
    )
    mod_content = re.sub(r'(^|\n)(ATOMIC_SPECIES)', f'\n{ions_cell_block}\\2', mod_content, count=1)
    pressure_effect = False
    user_input = input("Do you want to apply pressure effect? (yes/no)(default: no): ").strip().lower()
    if user_input == 'yes':
        pressure_effect = True
    if pressure_effect:
        # Get pressure value with error handling
        while True:
            press_value = input("Enter pressure value in kbar: ").strip()
            try:
                press_value_float = float(press_value)
                break
            except ValueError:
                print("Invalid input. Please enter a numeric value for pressure (e.g., 5.0).")

        while True:
            press_conv_thr_value = input("Enter pressure convergence threshold: ").strip()
            try:
                press_conv_thr_float = float(press_conv_thr_value)
                break
            except ValueError:
                print("Invalid input. Please enter a numeric value for pressure convergence threshold (e.g., 0.1).")
    
        mod_content = re.sub(r"press\s*=\s*[\d.]+", f"press = {press_value_float}", mod_content)
        mod_content = re.sub(r"press_conv_thr\s*=\s*[\d.]+", f"press_conv_thr = {press_conv_thr_float}", mod_content)
        
    
    # Create new input and output filenames
    vc_relax_input = f"{file_prefix}.vc_relax.in"
    vc_relax_output = f"{file_prefix}.vc_relax.out"
    
    # write the modified input file
    with open(vc_relax_input, 'w') as f:
        f.write(mod_content)    
        
    print(f"\nGenerated {vc_relax_input} with k-points={suggested_kp_x}x{suggested_kp_y}x{suggested_kp_z}, ecutwfc={suggested_ecutwfc}, degauss={suggested_degauss}")
    
    # Run the calculation
    print(f"Running calculation: {vc_relax_input}")
    success = run_pw_calculation(vc_relax_input, vc_relax_output, num_cores)    

    if not success:
        print(f"\n✗ FATAL ERROR: Calculation failed for {vc_relax_input}")
        print("The pw.x calculation did not complete successfully.")
        print("Please check:")
        print("- Input file syntax and parameters")
        print("- Pseudopotential files availability")
        print("- System resources (memory, disk space)")
        print("- MPI configuration")
        print(f"- Check the output file: {vc_relax_output}")
        sys.exit(1)
    print(f"✓ {vc_relax_input} completed successfully") 
    
    # Extracting data from the vc_relax output file
    celldm_block = extract_data_from_vc_relax_output(output_file=vc_relax_output, start_pattern="ibrav", end_pattern="Input lattice vectors")
    atomic_positions_block = extract_data_from_vc_relax_output(output_file=vc_relax_output, start_pattern="ATOMIC_POSITIONS", end_pattern="End final coordinates")
    generate_tuned_scf_input(suggested_kp_x, suggested_kp_y, suggested_kp_z, suggested_ecutwfc, suggested_degauss, celldm_block, atomic_positions_block)

def extract_data_from_vc_relax_output(output_file, start_pattern, end_pattern): 
    """
    Extracts the last block of text between start and end patterns from the output file.
    Does NOT include the start or end pattern lines in the returned block.

    Returns:
        str: The last block found, or an empty string if not found.
    """

    block = []
    inside_block = False

    try:
        with open(output_file, 'r') as f:
            for line in f:
                if start_pattern in line:
                    block = []  # Start new block, overwrite previous, do not include this line
                    inside_block = True
                    continue
                if inside_block:
                    if end_pattern in line:
                        inside_block = False  # End of block, do not include this line
                        continue
                    block.append(line)
        return ''.join(block) if block else ""
    except Exception as e:
        print(f"Error reading {output_file}: {e}")
        return ""
   
def get_tuned_scf():
        
    # suggested_kp_x, suggested_kp_y, suggested_kp_z, suggested_ecutwfc, suggested_degauss = check_convergence()  
    # print(suggested_degauss)
    suggested_kp_x = 9 
    suggested_kp_y = 9
    suggested_kp_z = 8
    suggested_ecutwfc = 50
    suggested_degauss = 0.020
    suggested_degauss = f"{suggested_degauss:.3f}"
    
    # Save current working directory
    original_cwd = os.getcwd()
    output_dir = "SOC.convergence"
    # Change to the outdir directory, create if it doesn't exist
    if not os.path.isdir(output_dir):
        os.makedirs(output_dir, exist_ok=True)
    os.chdir(output_dir)
    
    vc_relax_run(suggested_kp_x= suggested_kp_x, suggested_kp_y= suggested_kp_y, suggested_kp_z= suggested_kp_z, 
                    suggested_ecutwfc= suggested_ecutwfc, suggested_degauss= suggested_degauss)
    # Check if the tuned_scf.in file exists
    tuned_scf_input = f"{file_prefix}.SOC.tuned_scf.in"
    if not os.path.isfile(tuned_scf_input):
        print(f"Error: Tuned SCF input file {tuned_scf_input} not found!")
        print("Please make sure the vc-relax calculation was completed successfully.")
        sys.exit(1)
    else:
        print(f"Found tuned SCF input file: {tuned_scf_input}")
    pass 
    # Change back to the original working directory
    os.chdir(original_cwd)
    
    #copy the tuned_scf.in file to the original working directory 
    src_path = os.path.join(output_dir, tuned_scf_input)
    dst_path = os.path.join(original_cwd, tuned_scf_input)
    try:
        shutil.copy(src_path, dst_path)
        print(f"Copied {tuned_scf_input} from {output_dir} to {original_cwd}")
    except Exception as e:
        print(f"Error copying {tuned_scf_input}: {e}")

def band_run(output_dir='' ):
    # Check if the reference input file exists
    ref_input = f"{file_prefix}.SOC.tuned_scf.in"
    if not os.path.isfile(ref_input):
        print(f"Error: Reference file {ref_input} not found!")
        print("Please make sure this k-point combination was generated in the previous step.")
    else:
        print(f"Found reference file: {ref_input}")
    pass

    #Read the reference input file
    with open(ref_input, 'r') as f:
        ref_content = f.read()
        
    # Check if output_dir is provided, if not, use default
    if output_dir == "":
        output_dir = f"{file_prefix}.SOC.Band"
    
    #create new scf content    
    scf_content = ref_content
    scf_content = re.sub(r"outdir\s*=\s*['\"].*?['\"]", f'outdir = "./"', scf_content)
    scf_content = re.sub(r"calculation\s*=\s*['\"].*?['\"]", "calculation = 'scf'", scf_content)
    scf_input = f"{file_prefix}.scf.in"
    scf_output = f"{file_prefix}.scf.out"
    
    nscf_content = ref_content
    # Create new input file for nscf with modified parameters
    nscf_content = re.sub(r"outdir\s*=\s*['\"].*?['\"]", f'outdir = "./"', nscf_content)
    nscf_content = re.sub(r"calculation\s*=\s*['\"].*?['\"]", "calculation = 'bands'", nscf_content)
    # Replace the line starting with 'K_POINTS' with 'K_POINTS {tpiba_b}'
    nscf_content = re.sub(r'^K_POINTS.*$', 'K_POINTS {tpiba_b}', nscf_content, flags=re.MULTILINE)
    
        # Suggest nbnd value based on valence electrons and atom counts

    # Extract ATOMIC_SPECIES and ATOMIC_POSITIONS blocks from ref_content
    species_lines = []
    positions_lines = []
    lines = ref_content.splitlines()
    in_species = False
    in_positions = False
    for line in lines:
        if line.strip().startswith("ATOMIC_SPECIES"):
            in_species = True
            in_positions = False
            continue
        if line.strip().startswith("ATOMIC_POSITIONS"):
            in_positions = True
            in_species = False
            continue
        if line.strip().startswith("K_POINTS"):
            in_positions = False
        if in_species:
            if line.strip() == "" or line.strip().startswith("ATOMIC_POSITIONS"):
                continue
            species_lines.append(line.strip())
        if in_positions:
            if line.strip() == "" or line.strip().startswith("K_POINTS"):
                continue
            positions_lines.append(line.strip())

    # Parse atom types and pseudofile names
    atom_pseudos = {}
    for l in species_lines:
        parts = l.split()
        if len(parts) >= 3:
            atom = parts[0]
            pseudo = parts[2]
            atom_pseudos[atom] = pseudo

    # Count occurrences of each atom in ATOMIC_POSITIONS
    atom_counts = Counter()
    for l in positions_lines:
        parts = l.split()
        if len(parts) >= 1:
            atom = parts[0]
            atom_counts[atom] += 1

    # For each atom, read its pseudofile and sum valence electrons
    total_valence_electrons = 0
    for atom, pseudo in atom_pseudos.items():
        pseudo_path = pseudo
        # Try to find pseudo file in current dir or home_dir
        if not os.path.isfile(pseudo_path):
            pseudo_path = os.path.join(home_dir, pseudo)
        valence_e = 0
        if os.path.isfile(pseudo_path):
            with open(pseudo_path, "r") as pf:
                lines = pf.readlines()
            in_valence = False
            for line in lines:
                if "Valence configuration" in line:
                    in_valence = True
                    continue
                if "Generation configuration" in line:
                    break
                if in_valence:
                    parts = line.split()
                    if len(parts) >= 5:
                        try:
                            occ = float(parts[3])
                            valence_e += occ
                        except Exception:
                            continue
        total_valence_electrons += valence_e * atom_counts.get(atom, 0)

    suggested_nbnd = int(4 * total_valence_electrons + 0.5)
    nband_value = input(f"Enter the nbnd value (suggested: {suggested_nbnd}): ").strip()
    
    nscf_content = re.sub(r'&SYSTEM', f'&SYSTEM\n                        nbnd = {nband_value}\n                       nosym = .false.', nscf_content)

    # Ask for high symmetry points path
    # Try to read high symmetry points from file first
    hsp_file_path = f"{file_prefix}_high_sys_points.used"
    if os.path.isfile(hsp_file_path):
        with open(hsp_file_path, 'r') as f:
            hsp_input = f.read().strip()
        print(f"Read high symmetry points from file: {hsp_file_path}")
    else:
        # Ask for high symmetry points path
        hsp_input = input("Enter the path of high symmetry points (space-separated, e.g., gG X W X K gG L): ").strip()
        # Save high symmetry points to a file
        os.makedirs(f"{file_prefix}.Band", exist_ok=True)
        with open(hsp_file_path, 'w') as f:
            f.write(hsp_input + '\n')
        print(f"Saved high symmetry points to file: {hsp_file_path}")
    hsp_list = hsp_input.split()
    nks = len(hsp_list)
    weight = 50  ##change this later
    hsp_list_with_weight = [f"{hsp} {weight}" for hsp in hsp_list]
    
    # Remove the old automatic k-points line
    nscf_content = re.sub(r'^\s*\d+\s+\d+\s+\d+\s+0\s+0\s+0\s*$', '', nscf_content, flags=re.MULTILINE)
    # Insert new k-points block after 'K_POINTS {tpiba_b}'
    kpoints_block = f"{nks}\n" + "\n".join(hsp_list_with_weight)
    nscf_content = re.sub(r'(K_POINTS\s*\{tpiba_b\})', r'\1\n' + kpoints_block, nscf_content)

    # create new input and output filenames
    nscf_bands_input = f"{file_prefix}.nscf_bands.in"
    nscf_bands_output = f"{file_prefix}.nscf_bands.out"
    
    # create bands input content
    bands_input_content = []
    bands_input_content.append("&BANDS\n")
    bands_input_content.append(f"   prefix = '{file_prefix}'\n")
    bands_input_content.append(f"   outdir = './'\n")
    bands_input_content.append(f"   filband = '{file_prefix}.bands'\n")
    bands_input_content.append("/\n")
    bands_input_content = "".join(bands_input_content)
    #create input for bands.in
    band_run_input = f"{file_prefix}.bands.in"
    
    # Save current working directory
    original_cwd = os.getcwd()
    try:
        # Change to the outdir directory, create if it doesn't exist
        if not os.path.isdir(output_dir):
            os.makedirs(output_dir, exist_ok=True)
        os.chdir(output_dir)
        # All subsequent file operations will be in outdir
        
        # write the modified scf input file
        with open(scf_input, 'w') as f:
            f.write(scf_content) 
        print(f"\nGenerated {scf_input}.")
        # Run the scf calculation
        print(f"Running calculation: {scf_input}")
        success = run_pw_calculation(scf_input, scf_output, num_cores)
        if not success:
            print(f"\n✗ FATAL ERROR: Calculation failed for {scf_input}")
            print("The pw.x calculation did not complete successfully.")
            print("Please check:")
            print("- Input file syntax and parameters")
            print("- Pseudopotential files availability")
            print("- System resources (memory, disk space)")
            print("- MPI configuration")
            print(f"- Check the output file: {scf_output}")
            sys.exit(1)
        print(f"✓ {scf_input} completed successfully")
        
        
        # write the modified nscf input file
        with open(nscf_bands_input, 'w') as f:
            f.write(nscf_content)

        print(f"\nGenerated {nscf_bands_input}.")
        print(f"Running calculation: {nscf_bands_input}")
        success = run_pw_calculation(nscf_bands_input, nscf_bands_output, num_cores)
        if not success:
            print(f"\n✗ FATAL ERROR: Calculation failed for {nscf_bands_input}")
            print("The pw.x calculation did not complete successfully.")
            print("Please check:")
            print("- Input file syntax and parameters")
            print("- Pseudopotential files availability")
            print("- System resources (memory, disk space)")
            print("- MPI configuration")
            print(f"- Check the output file: {nscf_bands_output}")
            sys.exit(1)
        print(f"✓ {nscf_bands_input} completed successfully")
        
        # (bands_input_content is written in outdir, and bands.x will run here)
        with open(band_run_input, 'w') as f:
            f.write(bands_input_content)
        print(f"\nGenerated {band_run_input}.")
        # Run the bands calculation
        print(f"Running bands calculation: {band_run_input}")
        success = run_bands_calculation(band_run_input, f"{file_prefix}.bands.out", num_cores)
        if not success:
            print(f"\n✗ FATAL ERROR: Calculation failed for {band_run_input}")
            print("The pw.x calculation did not complete successfully.")
            print("Please check:")
            print("- Input file syntax and parameters")
            print("- Pseudopotential files availability")
            print("- System resources (memory, disk space)")
            print("- MPI configuration")
            print(f"- Check the output file: {file_prefix}.bands.out")
            sys.exit(1)
        print(f"✓ {band_run_input} completed successfully")
        
    
        scfout_file = f"{file_prefix}.scf.out"
        nscf_band_file = f"{file_prefix}.nscf_bands.in"
        bandsout_file = f"{file_prefix}.bands.out"
        gnufile = f"{file_prefix}.bands.gnu"
        plot = plot_bands_from_gnu(
            scfout=scfout_file,
            nscfin=nscf_band_file,
            bandsout=bandsout_file,
            gnufile=gnufile
        )
        print(f"Generated bands plot: {plot}")
    finally:
        # Change back to the original working directory
        os.chdir(original_cwd)
            
def dos_run(output_dir=''):
    # Check if the reference input file exists
    ref_input = f"{file_prefix}.SOC.tuned_scf.in"
    if not os.path.isfile(ref_input):
        print(f"Error: Reference file {ref_input} not found!")
        print("Please make sure this k-point combination was generated in the previous step.")
    else:
        print(f"Found reference file: {ref_input}")
    pass

    #Read the reference input file
    with open(ref_input, 'r') as f:
        ref_content = f.read()
        
    # Check if output_dir is provided, if not, use default
    if output_dir == "":
        output_dir = f"{file_prefix}.SOC.Dos"

    scf_content = ref_content
    # Create new input file for scf calculation
    scf_content = re.sub(r"outdir\s*=\s*['\"].*?['\"]", f"outdir = './'", scf_content)
    scf_content = re.sub(r"calculation\s*=\s*['\"].*?['\"]", "calculation = 'scf'", scf_content)
    scf_content = re.sub(r"occupations\s*=\s*['\"].*?['\"]", "occupations = 'tetrahedra_opt'", scf_content)
    scf_content = re.sub(r"^\s*smearing\s*=\s*['\"].*?['\"]\s*\n?", "", scf_content, flags=re.MULTILINE)
    scf_input = f"{file_prefix}.dos.scf.in"
    scf_output = f"{file_prefix}.dos.scf.out"
    
    # Create new input file for nscf calculation
    nscf_content = scf_content
    nscf_content = re.sub(r"calculation\s*=\s*['\"].*?['\"]", "calculation = 'nscf'", nscf_content)
    nscf_content = re.sub(r'^\s*\d+\s+\d+\s+\d+\s+0\s+0\s+0\s*$', '24  24  24   0 0 0', nscf_content, flags=re.MULTILINE)
    nscf_input = f"{file_prefix}.dos.nscf.in"
    nscf_output = f"{file_prefix}.dos.nscf.out"
    
    # Create new input file for dos calculation
    dos_content = []
    dos_content.append("&DOS\n")
    dos_content.append(f"   prefix = '{file_prefix}'\n")
    dos_content.append(f"   outdir = './'\n")
    dos_content.append(f"   fildos = '{file_prefix}.dos'\n")
    dos_content.append(f"   DeltaE = 0.01\n") 
    dos_content.append(f"/\n")
    dos_content = "".join(dos_content)
    dos_input = f"{file_prefix}.dos.in"
    dos_output = f"{file_prefix}.dos.out"
    
    # Save current working directory
    original_cwd = os.getcwd()
    try:
        # Change to the outdir directory, create if it doesn't exist
        if not os.path.isdir(output_dir):
            os.makedirs(output_dir, exist_ok=True)
        os.chdir(output_dir)
        
        # run the scf calculation
        with open(scf_input, 'w') as f:
            f.write(scf_content)
        print(f"\nGenerated {scf_input}.")
        run_pw_calculation(scf_input, scf_output, num_cores)
        
        #run the nscf calculation
        with open(nscf_input, 'w') as f:
            f.write(nscf_content)
        print(f"\nGenerated {nscf_input}.")
        run_pw_calculation(nscf_input, nscf_output, num_cores)
        
        # run the dos calculation
        with open(dos_input, 'w') as f:
            f.write(dos_content)
        print(f"\nGenerated {dos_input}.")
        run_dos_calculation(dos_input, dos_output, num_cores)
        
        

    finally:
        # Change back to the original working directory
        os.chdir(original_cwd)

def pdos_run(output_dir=''):
    # Check if the reference input file exists
    ref_input = f"{file_prefix}.SOC.tuned_scf.in"
    if not os.path.isfile(ref_input):
        print(f"Error: Reference file {ref_input} not found!")
        print("Please make sure this k-point combination was generated in the previous step.")
    else:
        print(f"Found reference file: {ref_input}")
    pass

    #Read the reference input file
    with open(ref_input, 'r') as f:
        ref_content = f.read()
        
    # Check if output_dir is provided, if not, use default
    if output_dir == "":
        output_dir = f"{file_prefix}.SOC.Pdos"

    scf_content = ref_content
    # Create new input file for scf calculation
    scf_content = re.sub(r"outdir\s*=\s*['\"].*?['\"]", f"outdir = './'", scf_content)
    scf_content = re.sub(r"calculation\s*=\s*['\"].*?['\"]", "calculation = 'scf'", scf_content)
    scf_content = re.sub(r"occupations\s*=\s*['\"].*?['\"]", "occupations = 'tetrahedra_opt'", scf_content)
    scf_content = re.sub(r"^\s*smearing\s*=\s*['\"].*?['\"]\s*\n?", "", scf_content, flags=re.MULTILINE)
    scf_input = f"{file_prefix}.pdos.scf.in"
    scf_output = f"{file_prefix}.pdos.scf.out"
    
    # Create new input file for nscf calculation
    nscf_content = scf_content
    nscf_content = re.sub(r"calculation\s*=\s*['\"].*?['\"]", "calculation = 'nscf'", nscf_content)
    nscf_content = re.sub(r'^\s*\d+\s+\d+\s+\d+\s+0\s+0\s+0\s*$', '24  24  24   0 0 0', nscf_content, flags=re.MULTILINE)
    nscf_input = f"{file_prefix}.pdos.nscf.in"
    nscf_output = f"{file_prefix}.pdos.nscf.out"
    
    # Create new input file for projwfc calculation
    projwfc_content = []
    projwfc_content.append("&PROJWFC\n")
    projwfc_content.append(f"   prefix = '{file_prefix}'\n")
    projwfc_content.append(f"   outdir = './'\n")
    projwfc_content.append(f"   filpdos = '{file_prefix}.pdos'\n")
    projwfc_content.append(f"   DeltaE = 0.01\n")
    projwfc_content.append(f"/\n")
    projwfc_content = "".join(projwfc_content)
    projwfc_input = f"{file_prefix}.projwfc.in"
    projwfc_output = f"{file_prefix}.projwfc.out"
    
    # create new input file for sumpdos calculation
    sumpdos_content = []
    
    # Save current working directory
    original_cwd = os.getcwd()
    try:
        # Change to the outdir directory, create if it doesn't exist
        if not os.path.isdir(output_dir):
            os.makedirs(output_dir, exist_ok=True)
        os.chdir(output_dir)
        
        # run the scf calculation
        with open(scf_input, 'w') as f:
            f.write(scf_content)
        print(f"\nGenerated {scf_input}.")
        run_pw_calculation(scf_input, scf_output, num_cores)    
        
        # run the nscf calculation
        with open(nscf_input, 'w') as f:
            f.write(nscf_content)
        print(f"\nGenerated {nscf_input}.")
        run_pw_calculation(nscf_input, nscf_output, num_cores)

        # run the projwfc calculation
        with open(projwfc_input, 'w') as f:
            f.write(projwfc_content)
        print(f"\nGenerated {projwfc_input}.")
        run_projwfc_calculation(projwfc_input, projwfc_output, num_cores)
        
        # run the sumpdos calculation
        # Find atom types from scf_content
        atom_types = []
        in_atomic_species = False
        for line in scf_content.splitlines():
            if line.strip().startswith("ATOMIC_SPECIES"):
                in_atomic_species = True
                continue
            if in_atomic_species:
                if line.strip() == "" or line.strip().startswith("ATOMIC_POSITIONS"):
                    break
                parts = line.strip().split()
                if len(parts) >= 1:
                    atom_types.append(parts[0])
        orbitals = ['s', 'p', 'd', 'f']  # Define the orbitals to sum over        
        #summed pdos content
        print(f"\nGenerating and running summed PDOS files for each atom type and orbital...")
        for atom in atom_types:
            for orbital in orbitals:
                # Check if files matching the pattern exist in the directory
                pattern = f"*({atom})*({orbital}*"
                matching_files = glob.glob(pattern)
                if not matching_files:
                    continue
                sumpdos_input = f"*\\({atom}\\)*\\({orbital}*"
                
                sumpdos_output = f"atom_{atom}_{orbital}.dat"
                run_sumpdos_calculation(sumpdos_input, sumpdos_output)
            sumpdos_input = f"*\\({atom}\\)*"
            sumpdos_output = f"atom_{atom}_total.dat"
            run_sumpdos_calculation(sumpdos_input, sumpdos_output)
        print(f"✓ summed PDOS run completed successfully")

        # Combine orbital and total PDOS files for each atom into a CSV

        for atom in atom_types:
            csv_filename = f"atom_{atom}_pdos.csv"
            data = {}
            energy = []
            # Read orbital files
            available_orbitals = []
            for orbital in orbitals + ['total']:
                dat_file = f"atom_{atom}_{orbital}.dat"
                if not os.path.isfile(dat_file):
                    continue
                available_orbitals.append(orbital)
                with open(dat_file, 'r') as f:
                    lines = [line for line in f if not line.strip().startswith('#') and line.strip()]
                    col1 = []
                    col2 = []
                    for line in lines:
                        parts = line.split()
                        if len(parts) >= 2:
                            col1.append(float(parts[0]))
                            col2.append(float(parts[1].replace('E', 'e')))
                    if not energy:
                        energy = col1
                    data[orbital] = col2
            # Write CSV only for available orbitals
            if energy and data:
                with open(csv_filename, 'w', newline='') as csvfile:
                    writer = csv.writer(csvfile)
                    header = ['Energy(eV)'] + [f'PDOS_{orb}' for orb in available_orbitals]
                    writer.writerow(header)
                    for i in range(len(energy)):
                        row = [energy[i]]
                        for orb in available_orbitals:
                            row.append(data.get(orb, [None]*len(energy))[i] if orb in data else '')
                        writer.writerow(row)
                print(f"Combined PDOS CSV written: {csv_filename}")
                
            # Plot energy vs Density of States
            if energy and data:
                # Define a color map for orbitals
                color_map = {
                    's': '#1f77b4',      # blue
                    'p': '#ff7f0e',      # orange
                    'd': '#2ca02c',      # green
                    'f': '#d62728',      # red
                    'total': '#000000'   # black
                }
                # Use a publication-quality style
                plt.style.use('seaborn-v0_8-white')
                mpl.rcParams.update({
                    'font.size': 14,
                    'axes.labelsize': 16,
                    'axes.titlesize': 18,
                    'legend.fontsize': 14,
                    'xtick.labelsize': 13,
                    'ytick.labelsize': 13,
                    'axes.linewidth': 1.2,
                    'lines.linewidth': 1,  # thinner lines
                    'figure.dpi': 300,
                    'savefig.dpi': 300,
                    'axes.grid': False,
                    'legend.frameon': False,
                    'xtick.direction': 'in',
                    'ytick.direction': 'in',
                    'xtick.top': True,
                    'ytick.right': True,
                    'figure.figsize': (7, 5)
                })

                # Plot orbitals only (no total)
                fig, ax = plt.subplots()
                for orb in available_orbitals:
                    if orb != 'total':
                        ax.plot(
                            energy, data[orb],
                            label=f'{orb}',
                            color=color_map.get(orb, None),
                            linewidth=1  # thinner line
                        )
                ax.set_xlabel('Energy (eV)')
                ax.set_ylabel('Density of States (electrons/eV)')
                ax.set_title(f'PDOS for {atom}', pad=12)
                ax.legend(title='Orbital', loc='upper right')
                ax.axvline(0, color='grey', linestyle='--', linewidth=1, alpha=0.7)
                ax.spines['top'].set_visible(True)
                ax.spines['right'].set_visible(True)
                plt.tight_layout()
                plt.savefig(f"{atom}_pdos.png")
                plt.close()

                # Plot orbitals and total
                fig, ax = plt.subplots()
                for orb in available_orbitals:
                    ax.plot(
                        energy, data[orb],
                        label=f'{orb}',
                        color=color_map.get(orb, None),
                        linestyle='-',  # always solid
                        linewidth=1  # thinner line for all
                    )
                ax.set_xlabel('Energy (eV)')
                ax.set_ylabel('Density of States (electrons/eV)')
                ax.set_title(f'PDOS for {atom}', pad=12)
                ax.legend(title='Orbital', loc='upper right')
                ax.axvline(0, color='grey', linestyle='--', linewidth=1, alpha=0.7)
                ax.spines['top'].set_visible(True)
                ax.spines['right'].set_visible(True)
                plt.tight_layout()
                plt.savefig(f"{atom}_pdos_total.png")
                plt.close()
    
    finally:
        # Change back to the original working directory
        os.chdir(original_cwd)      

global file_prefix, filename, num_cores, sg, do_ibrav, home_dir 
